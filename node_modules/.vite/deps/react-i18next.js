import { __commonJS, __toESM, require_react } from "./react-CSb6HjG4.js";
import { keysFromSelector } from "./i18next-BGsYQNDc.js";

//#region node_modules/void-elements/index.js
var require_void_elements = /* @__PURE__ */ __commonJS({ "node_modules/void-elements/index.js": ((exports, module) => {
	/**
	* This file automatically generated from `pre-publish.js`.
	* Do not manually edit.
	*/
	module.exports = {
		"area": true,
		"base": true,
		"br": true,
		"col": true,
		"embed": true,
		"hr": true,
		"img": true,
		"input": true,
		"link": true,
		"meta": true,
		"param": true,
		"source": true,
		"track": true,
		"wbr": true
	};
}) });

//#endregion
//#region node_modules/html-parse-stringify/dist/html-parse-stringify.module.js
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var import_void_elements = /* @__PURE__ */ __toESM(require_void_elements());
var t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
function n(n$1) {
	var r$1 = {
		type: "tag",
		name: "",
		voidElement: !1,
		attrs: {},
		children: []
	}, i$1 = n$1.match(/<\/?([^\s]+?)[/\s>]/);
	if (i$1 && (r$1.name = i$1[1], (import_void_elements.default[i$1[1]] || "/" === n$1.charAt(n$1.length - 2)) && (r$1.voidElement = !0), r$1.name.startsWith("!--"))) {
		var s$1 = n$1.indexOf("-->");
		return {
			type: "comment",
			comment: -1 !== s$1 ? n$1.slice(4, s$1) : ""
		};
	}
	for (var a$1 = new RegExp(t), c$1 = null; null !== (c$1 = a$1.exec(n$1));) if (c$1[0].trim()) if (c$1[1]) {
		var o = c$1[1].trim(), l = [o, ""];
		o.indexOf("=") > -1 && (l = o.split("=")), r$1.attrs[l[0]] = l[1], a$1.lastIndex--;
	} else c$1[2] && (r$1.attrs[c$1[2]] = c$1[3].trim().substring(1, c$1[3].length - 1));
	return r$1;
}
var r = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g, i = /^\s*$/, s = Object.create(null);
function a(e$1, t$1) {
	switch (t$1.type) {
		case "text": return e$1 + t$1.content;
		case "tag": return e$1 += "<" + t$1.name + (t$1.attrs ? function(e$2) {
			var t$2 = [];
			for (var n$1 in e$2) t$2.push(n$1 + "=\"" + e$2[n$1] + "\"");
			return t$2.length ? " " + t$2.join(" ") : "";
		}(t$1.attrs) : "") + (t$1.voidElement ? "/>" : ">"), t$1.voidElement ? e$1 : e$1 + t$1.children.reduce(a, "") + "</" + t$1.name + ">";
		case "comment": return e$1 + "<!--" + t$1.comment + "-->";
	}
}
var c = {
	parse: function(e$1, t$1) {
		t$1 || (t$1 = {}), t$1.components || (t$1.components = s);
		var a$1, c$1 = [], o = [], l = -1, m = !1;
		if (0 !== e$1.indexOf("<")) {
			var u = e$1.indexOf("<");
			c$1.push({
				type: "text",
				content: -1 === u ? e$1 : e$1.substring(0, u)
			});
		}
		return e$1.replace(r, function(r$1, s$1) {
			if (m) {
				if (r$1 !== "</" + a$1.name + ">") return;
				m = !1;
			}
			var u$1, f = "/" !== r$1.charAt(1), h = r$1.startsWith("<!--"), p = s$1 + r$1.length, d = e$1.charAt(p);
			if (h) {
				var v = n(r$1);
				return l < 0 ? (c$1.push(v), c$1) : ((u$1 = o[l]).children.push(v), c$1);
			}
			if (f && (l++, "tag" === (a$1 = n(r$1)).type && t$1.components[a$1.name] && (a$1.type = "component", m = !0), a$1.voidElement || m || !d || "<" === d || a$1.children.push({
				type: "text",
				content: e$1.slice(p, e$1.indexOf("<", p))
			}), 0 === l && c$1.push(a$1), (u$1 = o[l - 1]) && u$1.children.push(a$1), o[l] = a$1), (!f || a$1.voidElement) && (l > -1 && (a$1.voidElement || a$1.name === r$1.slice(2, -1)) && (l--, a$1 = -1 === l ? c$1 : o[l]), !m && "<" !== d && d)) {
				u$1 = -1 === l ? c$1 : o[l].children;
				var x = e$1.indexOf("<", p), g = e$1.slice(p, -1 === x ? void 0 : x);
				i.test(g) && (g = " "), (x > -1 && l + u$1.length >= 0 || " " !== g) && u$1.push({
					type: "text",
					content: g
				});
			}
		}), c$1;
	},
	stringify: function(e$1) {
		return e$1.reduce(function(e$2, t$1) {
			return e$2 + a("", t$1);
		}, "");
	}
};
var html_parse_stringify_module_default = c;

//#endregion
//#region node_modules/react-i18next/dist/es/utils.js
const warn = (i18n, code, msg, rest) => {
	const args = [msg, {
		code,
		...rest || {}
	}];
	if (i18n?.services?.logger?.forward) return i18n.services.logger.forward(args, "warn", "react-i18next::", true);
	if (isString(args[0])) args[0] = `react-i18next:: ${args[0]}`;
	if (i18n?.services?.logger?.warn) i18n.services.logger.warn(...args);
	else if (console?.warn) console.warn(...args);
};
var alreadyWarned = {};
const warnOnce = (i18n, code, msg, rest) => {
	if (isString(msg) && alreadyWarned[msg]) return;
	if (isString(msg)) alreadyWarned[msg] = /* @__PURE__ */ new Date();
	warn(i18n, code, msg, rest);
};
var loadedClb = (i18n, cb) => () => {
	if (i18n.isInitialized) cb();
	else {
		const initialized = () => {
			setTimeout(() => {
				i18n.off("initialized", initialized);
			}, 0);
			cb();
		};
		i18n.on("initialized", initialized);
	}
};
const loadNamespaces = (i18n, ns, cb) => {
	i18n.loadNamespaces(ns, loadedClb(i18n, cb));
};
const loadLanguages = (i18n, lng, ns, cb) => {
	if (isString(ns)) ns = [ns];
	if (i18n.options.preload && i18n.options.preload.indexOf(lng) > -1) return loadNamespaces(i18n, ns, cb);
	ns.forEach((n$1) => {
		if (i18n.options.ns.indexOf(n$1) < 0) i18n.options.ns.push(n$1);
	});
	i18n.loadLanguages(lng, loadedClb(i18n, cb));
};
const hasLoadedNamespace = (ns, i18n, options = {}) => {
	if (!i18n.languages || !i18n.languages.length) {
		warnOnce(i18n, "NO_LANGUAGES", "i18n.languages were undefined or empty", { languages: i18n.languages });
		return true;
	}
	return i18n.hasLoadedNamespace(ns, {
		lng: options.lng,
		precheck: (i18nInstance$1, loadNotPending) => {
			if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance$1.services.backendConnector.backend && i18nInstance$1.isLanguageChangingTo && !loadNotPending(i18nInstance$1.isLanguageChangingTo, ns)) return false;
		}
	});
};
const getDisplayName = (Component) => Component.displayName || Component.name || (isString(Component) && Component.length > 0 ? Component : "Unknown");
const isString = (obj) => typeof obj === "string";
const isObject = (obj) => typeof obj === "object" && obj !== null;

//#endregion
//#region node_modules/react-i18next/dist/es/unescape.js
var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
var htmlEntities = {
	"&amp;": "&",
	"&#38;": "&",
	"&lt;": "<",
	"&#60;": "<",
	"&gt;": ">",
	"&#62;": ">",
	"&apos;": "'",
	"&#39;": "'",
	"&quot;": "\"",
	"&#34;": "\"",
	"&nbsp;": " ",
	"&#160;": " ",
	"&copy;": "©",
	"&#169;": "©",
	"&reg;": "®",
	"&#174;": "®",
	"&hellip;": "…",
	"&#8230;": "…",
	"&#x2F;": "/",
	"&#47;": "/"
};
var unescapeHtmlEntity = (m) => htmlEntities[m];
const unescape = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);

//#endregion
//#region node_modules/react-i18next/dist/es/defaults.js
var defaultOptions = {
	bindI18n: "languageChanged",
	bindI18nStore: "",
	transEmptyNodeValue: "",
	transSupportBasicHtmlNodes: true,
	transWrapTextNodes: "",
	transKeepBasicHtmlNodesFor: [
		"br",
		"strong",
		"i",
		"p"
	],
	useSuspense: true,
	unescape
};
const setDefaults = (options = {}) => {
	defaultOptions = {
		...defaultOptions,
		...options
	};
};
const getDefaults = () => defaultOptions;

//#endregion
//#region node_modules/react-i18next/dist/es/i18nInstance.js
var i18nInstance;
const setI18n = (instance) => {
	i18nInstance = instance;
};
const getI18n = () => i18nInstance;

//#endregion
//#region node_modules/react-i18next/dist/es/TransWithoutContext.js
var hasChildren = (node, checkLength) => {
	if (!node) return false;
	const base = node.props?.children ?? node.children;
	if (checkLength) return base.length > 0;
	return !!base;
};
var getChildren = (node) => {
	if (!node) return [];
	const children = node.props?.children ?? node.children;
	return node.props?.i18nIsDynamicList ? getAsArray(children) : children;
};
var hasValidReactChildren = (children) => Array.isArray(children) && children.every(import_react.isValidElement);
var getAsArray = (data) => Array.isArray(data) ? data : [data];
var mergeProps = (source, target) => {
	const newTarget = { ...target };
	newTarget.props = Object.assign(source.props, target.props);
	return newTarget;
};
const nodesToString = (children, i18nOptions, i18n, i18nKey) => {
	if (!children) return "";
	let stringNode = "";
	const childrenArray = getAsArray(children);
	const keepArray = i18nOptions?.transSupportBasicHtmlNodes ? i18nOptions.transKeepBasicHtmlNodesFor ?? [] : [];
	childrenArray.forEach((child, childIndex) => {
		if (isString(child)) {
			stringNode += `${child}`;
			return;
		}
		if ((0, import_react.isValidElement)(child)) {
			const { props, type } = child;
			const childPropsCount = Object.keys(props).length;
			const shouldKeepChild = keepArray.indexOf(type) > -1;
			const childChildren = props.children;
			if (!childChildren && shouldKeepChild && !childPropsCount) {
				stringNode += `<${type}/>`;
				return;
			}
			if (!childChildren && (!shouldKeepChild || childPropsCount) || props.i18nIsDynamicList) {
				stringNode += `<${childIndex}></${childIndex}>`;
				return;
			}
			if (shouldKeepChild && childPropsCount === 1 && isString(childChildren)) {
				stringNode += `<${type}>${childChildren}</${type}>`;
				return;
			}
			const content = nodesToString(childChildren, i18nOptions, i18n, i18nKey);
			stringNode += `<${childIndex}>${content}</${childIndex}>`;
			return;
		}
		if (child === null) {
			warn(i18n, "TRANS_NULL_VALUE", `Passed in a null value as child`, { i18nKey });
			return;
		}
		if (isObject(child)) {
			const { format,...clone } = child;
			const keys = Object.keys(clone);
			if (keys.length === 1) {
				const value = format ? `${keys[0]}, ${format}` : keys[0];
				stringNode += `{{${value}}}`;
				return;
			}
			warn(i18n, "TRANS_INVALID_OBJ", `Invalid child - Object should only have keys {{ value, format }} (format is optional).`, {
				i18nKey,
				child
			});
			return;
		}
		warn(i18n, "TRANS_INVALID_VAR", `Passed in a variable like {number} - pass variables for interpolation as full objects like {{number}}.`, {
			i18nKey,
			child
		});
	});
	return stringNode;
};
var renderNodes = (children, knownComponentsMap, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) => {
	if (targetString === "") return [];
	const keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
	const emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.map((keep) => `<${keep}`).join("|")).test(targetString);
	if (!children && !knownComponentsMap && !emptyChildrenButNeedsHandling && !shouldUnescape) return [targetString];
	const data = knownComponentsMap ?? {};
	const getData = (childs) => {
		getAsArray(childs).forEach((child) => {
			if (isString(child)) return;
			if (hasChildren(child)) getData(getChildren(child));
			else if (isObject(child) && !(0, import_react.isValidElement)(child)) Object.assign(data, child);
		});
	};
	getData(children);
	const ast = html_parse_stringify_module_default.parse(`<0>${targetString}</0>`);
	const opts = {
		...data,
		...combinedTOpts
	};
	const renderInner = (child, node, rootReactNode) => {
		const childs = getChildren(child);
		const mappedChildren = mapAST(childs, node.children, rootReactNode);
		return hasValidReactChildren(childs) && mappedChildren.length === 0 || child.props?.i18nIsDynamicList ? childs : mappedChildren;
	};
	const pushTranslatedJSX = (child, inner, mem, i$1, isVoid) => {
		if (child.dummy) {
			child.children = inner;
			mem.push((0, import_react.cloneElement)(child, { key: i$1 }, isVoid ? void 0 : inner));
		} else mem.push(...import_react.Children.map([child], (c$1) => {
			const props = { ...c$1.props };
			delete props.i18nIsDynamicList;
			return (0, import_react.createElement)(c$1.type, {
				...props,
				key: i$1,
				ref: c$1.props.ref ?? c$1.ref
			}, isVoid ? null : inner);
		}));
	};
	const mapAST = (reactNode, astNode, rootReactNode) => {
		const reactNodes = getAsArray(reactNode);
		return getAsArray(astNode).reduce((mem, node, i$1) => {
			const translationContent = node.children?.[0]?.content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);
			if (node.type === "tag") {
				let tmp = reactNodes[parseInt(node.name, 10)];
				if (!tmp && knownComponentsMap) tmp = knownComponentsMap[node.name];
				if (rootReactNode.length === 1 && !tmp) tmp = rootReactNode[0][node.name];
				if (!tmp) tmp = {};
				const child = Object.keys(node.attrs).length !== 0 ? mergeProps({ props: node.attrs }, tmp) : tmp;
				const isElement = (0, import_react.isValidElement)(child);
				const isValidTranslationWithChildren = isElement && hasChildren(node, true) && !node.voidElement;
				const isEmptyTransWithHTML = emptyChildrenButNeedsHandling && isObject(child) && child.dummy && !isElement;
				const isKnownComponent = isObject(knownComponentsMap) && Object.hasOwnProperty.call(knownComponentsMap, node.name);
				if (isString(child)) {
					const value = i18n.services.interpolator.interpolate(child, opts, i18n.language);
					mem.push(value);
				} else if (hasChildren(child) || isValidTranslationWithChildren) {
					const inner = renderInner(child, node, rootReactNode);
					pushTranslatedJSX(child, inner, mem, i$1);
				} else if (isEmptyTransWithHTML) {
					const inner = mapAST(reactNodes, node.children, rootReactNode);
					pushTranslatedJSX(child, inner, mem, i$1);
				} else if (Number.isNaN(parseFloat(node.name))) if (isKnownComponent) {
					const inner = renderInner(child, node, rootReactNode);
					pushTranslatedJSX(child, inner, mem, i$1, node.voidElement);
				} else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) if (node.voidElement) mem.push((0, import_react.createElement)(node.name, { key: `${node.name}-${i$1}` }));
				else {
					const inner = mapAST(reactNodes, node.children, rootReactNode);
					mem.push((0, import_react.createElement)(node.name, { key: `${node.name}-${i$1}` }, inner));
				}
				else if (node.voidElement) mem.push(`<${node.name} />`);
				else {
					const inner = mapAST(reactNodes, node.children, rootReactNode);
					mem.push(`<${node.name}>${inner}</${node.name}>`);
				}
				else if (isObject(child) && !isElement) {
					const content = node.children[0] ? translationContent : null;
					if (content) mem.push(content);
				} else pushTranslatedJSX(child, translationContent, mem, i$1, node.children.length !== 1 || !translationContent);
			} else if (node.type === "text") {
				const wrapTextNodes = i18nOptions.transWrapTextNodes;
				const content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);
				if (wrapTextNodes) mem.push((0, import_react.createElement)(wrapTextNodes, { key: `${node.name}-${i$1}` }, content));
				else mem.push(content);
			}
			return mem;
		}, []);
	};
	const result = mapAST([{
		dummy: true,
		children: children || []
	}], ast, getAsArray(children || []));
	return getChildren(result[0]);
};
var fixComponentProps = (component, index, translation) => {
	const componentKey = component.key || index;
	const comp = (0, import_react.cloneElement)(component, { key: componentKey });
	if (!comp.props || !comp.props.children || translation.indexOf(`${index}/>`) < 0 && translation.indexOf(`${index} />`) < 0) return comp;
	function Componentized() {
		return (0, import_react.createElement)(import_react.Fragment, null, comp);
	}
	return (0, import_react.createElement)(Componentized, { key: componentKey });
};
var generateArrayComponents = (components, translation) => components.map((c$1, index) => fixComponentProps(c$1, index, translation));
var generateObjectComponents = (components, translation) => {
	const componentMap = {};
	Object.keys(components).forEach((c$1) => {
		Object.assign(componentMap, { [c$1]: fixComponentProps(components[c$1], c$1, translation) });
	});
	return componentMap;
};
var generateComponents = (components, translation, i18n, i18nKey) => {
	if (!components) return null;
	if (Array.isArray(components)) return generateArrayComponents(components, translation);
	if (isObject(components)) return generateObjectComponents(components, translation);
	warnOnce(i18n, "TRANS_INVALID_COMPONENTS", `<Trans /> "components" prop expects an object or array`, { i18nKey });
	return null;
};
var isComponentsMap = (object) => {
	if (!isObject(object)) return false;
	if (Array.isArray(object)) return false;
	return Object.keys(object).reduce((acc, key) => acc && Number.isNaN(Number.parseFloat(key)), true);
};
function Trans$1({ children, count, parent, i18nKey, context, tOptions = {}, values, defaults, components, ns, i18n: i18nFromProps, t: tFromProps, shouldUnescape,...additionalProps }) {
	const i18n = i18nFromProps || getI18n();
	if (!i18n) {
		warnOnce(i18n, "NO_I18NEXT_INSTANCE", `Trans: You need to pass in an i18next instance using i18nextReactModule`, { i18nKey });
		return children;
	}
	const t$1 = tFromProps || i18n.t.bind(i18n) || ((k) => k);
	const reactI18nextOptions = {
		...getDefaults(),
		...i18n.options?.react
	};
	let namespaces = ns || t$1.ns || i18n.options?.defaultNS;
	namespaces = isString(namespaces) ? [namespaces] : namespaces || ["translation"];
	const nodeAsString = nodesToString(children, reactI18nextOptions, i18n, i18nKey);
	const defaultValue = defaults || nodeAsString || reactI18nextOptions.transEmptyNodeValue || (typeof i18nKey === "function" ? keysFromSelector(i18nKey) : i18nKey);
	const { hashTransKey } = reactI18nextOptions;
	const key = i18nKey || (hashTransKey ? hashTransKey(nodeAsString || defaultValue) : nodeAsString || defaultValue);
	if (i18n.options?.interpolation?.defaultVariables) values = values && Object.keys(values).length > 0 ? {
		...values,
		...i18n.options.interpolation.defaultVariables
	} : { ...i18n.options.interpolation.defaultVariables };
	const interpolationOverride = values || count !== void 0 && !i18n.options?.interpolation?.alwaysFormat || !children ? tOptions.interpolation : { interpolation: {
		...tOptions.interpolation,
		prefix: "#$?",
		suffix: "?$#"
	} };
	const combinedTOpts = {
		...tOptions,
		context: context || tOptions.context,
		count,
		...values,
		...interpolationOverride,
		defaultValue,
		ns: namespaces
	};
	const translation = key ? t$1(key, combinedTOpts) : defaultValue;
	const generatedComponents = generateComponents(components, translation, i18n, i18nKey);
	let indexedChildren = generatedComponents || children;
	let componentsMap = null;
	if (isComponentsMap(generatedComponents)) {
		componentsMap = generatedComponents;
		indexedChildren = children;
	}
	const content = renderNodes(indexedChildren, componentsMap, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);
	const useAsParent = parent ?? reactI18nextOptions.defaultTransParent;
	return useAsParent ? (0, import_react.createElement)(useAsParent, additionalProps, content) : content;
}

//#endregion
//#region node_modules/react-i18next/dist/es/initReactI18next.js
const initReactI18next = {
	type: "3rdParty",
	init(instance) {
		setDefaults(instance.options.react);
		setI18n(instance);
	}
};

//#endregion
//#region node_modules/react-i18next/dist/es/context.js
const I18nContext = (0, import_react.createContext)();
var ReportNamespaces = class {
	constructor() {
		this.usedNamespaces = {};
	}
	addUsedNamespaces(namespaces) {
		namespaces.forEach((ns) => {
			if (!this.usedNamespaces[ns]) this.usedNamespaces[ns] = true;
		});
	}
	getUsedNamespaces() {
		return Object.keys(this.usedNamespaces);
	}
};
const composeInitialProps = (ForComponent) => async (ctx) => {
	const componentsInitialProps = await ForComponent.getInitialProps?.(ctx) ?? {};
	const i18nInitialProps = getInitialProps();
	return {
		...componentsInitialProps,
		...i18nInitialProps
	};
};
const getInitialProps = () => {
	const i18n = getI18n();
	const namespaces = i18n.reportNamespaces?.getUsedNamespaces() ?? [];
	const ret = {};
	const initialI18nStore = {};
	i18n.languages.forEach((l) => {
		initialI18nStore[l] = {};
		namespaces.forEach((ns) => {
			initialI18nStore[l][ns] = i18n.getResourceBundle(l, ns) || {};
		});
	});
	ret.initialI18nStore = initialI18nStore;
	ret.initialLanguage = i18n.language;
	return ret;
};

//#endregion
//#region node_modules/react-i18next/dist/es/Trans.js
function Trans({ children, count, parent, i18nKey, context, tOptions = {}, values, defaults, components, ns, i18n: i18nFromProps, t: tFromProps, shouldUnescape,...additionalProps }) {
	const { i18n: i18nFromContext, defaultNS: defaultNSFromContext } = (0, import_react.useContext)(I18nContext) || {};
	const i18n = i18nFromProps || i18nFromContext || getI18n();
	const t$1 = tFromProps || i18n?.t.bind(i18n);
	return Trans$1({
		children,
		count,
		parent,
		i18nKey,
		context,
		tOptions,
		values,
		defaults,
		components,
		ns: ns || t$1?.ns || defaultNSFromContext || i18n?.options?.defaultNS,
		i18n,
		t: tFromProps,
		shouldUnescape,
		...additionalProps
	});
}

//#endregion
//#region node_modules/react-i18next/dist/es/useTranslation.js
var usePrevious = (value, ignore) => {
	const ref = (0, import_react.useRef)();
	(0, import_react.useEffect)(() => {
		ref.current = ignore ? ref.current : value;
	}, [value, ignore]);
	return ref.current;
};
var alwaysNewT = (i18n, language, namespace, keyPrefix) => i18n.getFixedT(language, namespace, keyPrefix);
var useMemoizedT = (i18n, language, namespace, keyPrefix) => (0, import_react.useCallback)(alwaysNewT(i18n, language, namespace, keyPrefix), [
	i18n,
	language,
	namespace,
	keyPrefix
]);
const useTranslation = (ns, props = {}) => {
	const { i18n: i18nFromProps } = props;
	const { i18n: i18nFromContext, defaultNS: defaultNSFromContext } = (0, import_react.useContext)(I18nContext) || {};
	const i18n = i18nFromProps || i18nFromContext || getI18n();
	if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
	if (!i18n) {
		warnOnce(i18n, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
		const notReadyT = (k, optsOrDefaultValue) => {
			if (isString(optsOrDefaultValue)) return optsOrDefaultValue;
			if (isObject(optsOrDefaultValue) && isString(optsOrDefaultValue.defaultValue)) return optsOrDefaultValue.defaultValue;
			return Array.isArray(k) ? k[k.length - 1] : k;
		};
		const retNotReady = [
			notReadyT,
			{},
			false
		];
		retNotReady.t = notReadyT;
		retNotReady.i18n = {};
		retNotReady.ready = false;
		return retNotReady;
	}
	if (i18n.options.react?.wait) warnOnce(i18n, "DEPRECATED_OPTION", "useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
	const i18nOptions = {
		...getDefaults(),
		...i18n.options.react,
		...props
	};
	const { useSuspense, keyPrefix } = i18nOptions;
	let namespaces = ns || defaultNSFromContext || i18n.options?.defaultNS;
	namespaces = isString(namespaces) ? [namespaces] : namespaces || ["translation"];
	i18n.reportNamespaces.addUsedNamespaces?.(namespaces);
	const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n$1) => hasLoadedNamespace(n$1, i18n, i18nOptions));
	const memoGetT = useMemoizedT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
	const getT = () => memoGetT;
	const getNewT = () => alwaysNewT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
	const [t$1, setT] = (0, import_react.useState)(getT);
	let joinedNS = namespaces.join();
	if (props.lng) joinedNS = `${props.lng}${joinedNS}`;
	const previousJoinedNS = usePrevious(joinedNS);
	const isMounted = (0, import_react.useRef)(true);
	(0, import_react.useEffect)(() => {
		const { bindI18n, bindI18nStore } = i18nOptions;
		isMounted.current = true;
		if (!ready && !useSuspense) if (props.lng) loadLanguages(i18n, props.lng, namespaces, () => {
			if (isMounted.current) setT(getNewT);
		});
		else loadNamespaces(i18n, namespaces, () => {
			if (isMounted.current) setT(getNewT);
		});
		if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) setT(getNewT);
		const boundReset = () => {
			if (isMounted.current) setT(getNewT);
		};
		if (bindI18n) i18n?.on(bindI18n, boundReset);
		if (bindI18nStore) i18n?.store.on(bindI18nStore, boundReset);
		return () => {
			isMounted.current = false;
			if (i18n && bindI18n) bindI18n?.split(" ").forEach((e$1) => i18n.off(e$1, boundReset));
			if (bindI18nStore && i18n) bindI18nStore.split(" ").forEach((e$1) => i18n.store.off(e$1, boundReset));
		};
	}, [i18n, joinedNS]);
	(0, import_react.useEffect)(() => {
		if (isMounted.current && ready) setT(getT);
	}, [
		i18n,
		keyPrefix,
		ready
	]);
	const ret = [
		t$1,
		i18n,
		ready
	];
	ret.t = t$1;
	ret.i18n = i18n;
	ret.ready = ready;
	if (ready) return ret;
	if (!ready && !useSuspense) return ret;
	throw new Promise((resolve) => {
		if (props.lng) loadLanguages(i18n, props.lng, namespaces, () => resolve());
		else loadNamespaces(i18n, namespaces, () => resolve());
	});
};

//#endregion
//#region node_modules/react-i18next/dist/es/withTranslation.js
const withTranslation = (ns, options = {}) => function Extend(WrappedComponent) {
	function I18nextWithTranslation({ forwardedRef,...rest }) {
		const [t$1, i18n, ready] = useTranslation(ns, {
			...rest,
			keyPrefix: options.keyPrefix
		});
		const passDownProps = {
			...rest,
			t: t$1,
			i18n,
			tReady: ready
		};
		if (options.withRef && forwardedRef) passDownProps.ref = forwardedRef;
		else if (!options.withRef && forwardedRef) passDownProps.forwardedRef = forwardedRef;
		return (0, import_react.createElement)(WrappedComponent, passDownProps);
	}
	I18nextWithTranslation.displayName = `withI18nextTranslation(${getDisplayName(WrappedComponent)})`;
	I18nextWithTranslation.WrappedComponent = WrappedComponent;
	const forwardRef = (props, ref) => (0, import_react.createElement)(I18nextWithTranslation, Object.assign({}, props, { forwardedRef: ref }));
	return options.withRef ? (0, import_react.forwardRef)(forwardRef) : I18nextWithTranslation;
};

//#endregion
//#region node_modules/react-i18next/dist/es/Translation.js
const Translation = ({ ns, children,...options }) => {
	const [t$1, i18n, ready] = useTranslation(ns, options);
	return children(t$1, {
		i18n,
		lng: i18n.language
	}, ready);
};

//#endregion
//#region node_modules/react-i18next/dist/es/I18nextProvider.js
function I18nextProvider({ i18n, defaultNS, children }) {
	const value = (0, import_react.useMemo)(() => ({
		i18n,
		defaultNS
	}), [i18n, defaultNS]);
	return (0, import_react.createElement)(I18nContext.Provider, { value }, children);
}

//#endregion
//#region node_modules/react-i18next/dist/es/useSSR.js
const useSSR = (initialI18nStore, initialLanguage, props = {}) => {
	const { i18n: i18nFromProps } = props;
	const { i18n: i18nFromContext } = (0, import_react.useContext)(I18nContext) || {};
	const i18n = i18nFromProps || i18nFromContext || getI18n();
	if (i18n.options?.isClone) return;
	if (initialI18nStore && !i18n.initializedStoreOnce) {
		i18n.services.resourceStore.data = initialI18nStore;
		i18n.options.ns = Object.values(initialI18nStore).reduce((mem, lngResources) => {
			Object.keys(lngResources).forEach((ns) => {
				if (mem.indexOf(ns) < 0) mem.push(ns);
			});
			return mem;
		}, i18n.options.ns);
		i18n.initializedStoreOnce = true;
		i18n.isInitialized = true;
	}
	if (initialLanguage && !i18n.initializedLanguageOnce) {
		i18n.changeLanguage(initialLanguage);
		i18n.initializedLanguageOnce = true;
	}
};

//#endregion
//#region node_modules/react-i18next/dist/es/withSSR.js
const withSSR = () => function Extend(WrappedComponent) {
	function I18nextWithSSR({ initialI18nStore, initialLanguage,...rest }) {
		useSSR(initialI18nStore, initialLanguage);
		return (0, import_react.createElement)(WrappedComponent, { ...rest });
	}
	I18nextWithSSR.getInitialProps = composeInitialProps(WrappedComponent);
	I18nextWithSSR.displayName = `withI18nextSSR(${getDisplayName(WrappedComponent)})`;
	I18nextWithSSR.WrappedComponent = WrappedComponent;
	return I18nextWithSSR;
};

//#endregion
//#region node_modules/react-i18next/dist/es/index.js
const date = () => "";
const time = () => "";
const number = () => "";
const select = () => "";
const plural = () => "";
const selectOrdinal = () => "";

//#endregion
export { I18nContext, I18nextProvider, Trans, Trans$1 as TransWithoutContext, Translation, composeInitialProps, date, getDefaults, getI18n, getInitialProps, initReactI18next, number, plural, select, selectOrdinal, setDefaults, setI18n, time, useSSR, useTranslation, withSSR, withTranslation };
//# sourceMappingURL=react-i18next.js.map