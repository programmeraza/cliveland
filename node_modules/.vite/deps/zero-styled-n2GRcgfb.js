import { __commonJS, __toESM, require_react } from "./react-BaqBjuxQ.js";
import { require_prop_types } from "./prop-types-ClXjdD0r.js";
import { ThemeContext, _extends, getRegisteredStyles, insertStyles, memoize, registerStyles, serializeStyles, useInsertionEffectAlwaysWithSyncFallback, withEmotionCache } from "./emotion-react.browser.development.esm-C9cTS4XX.js";
import { require_jsx_runtime } from "./jsx-runtime-2WNxXIKR.js";

//#region node_modules/@mui/utils/esm/ClassNameGenerator/ClassNameGenerator.js
var defaultGenerator = (componentName) => componentName;
var createClassNameGenerator = () => {
	let generate = defaultGenerator;
	return {
		configure(generator) {
			generate = generator;
		},
		generate(componentName) {
			return generate(componentName);
		},
		reset() {
			generate = defaultGenerator;
		}
	};
};
var ClassNameGenerator = createClassNameGenerator();
var ClassNameGenerator_default = ClassNameGenerator;

//#endregion
//#region node_modules/@mui/utils/esm/capitalize/capitalize.js
function capitalize(string) {
	if (typeof string !== "string") throw new Error("MUI: `capitalize(string)` expects a string argument.");
	return string.charAt(0).toUpperCase() + string.slice(1);
}

//#endregion
//#region node_modules/@mui/utils/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = /* @__PURE__ */ __commonJS({ "node_modules/@mui/utils/node_modules/react-is/cjs/react-is.development.js": ((exports) => {
	(function() {
		function typeOf(object) {
			if ("object" === typeof object && null !== object) {
				var $$typeof = object.$$typeof;
				switch ($$typeof) {
					case REACT_ELEMENT_TYPE: switch (object = object.type, object) {
						case REACT_FRAGMENT_TYPE:
						case REACT_PROFILER_TYPE:
						case REACT_STRICT_MODE_TYPE:
						case REACT_SUSPENSE_TYPE:
						case REACT_SUSPENSE_LIST_TYPE:
						case REACT_VIEW_TRANSITION_TYPE: return object;
						default: switch (object = object && object.$$typeof, object) {
							case REACT_CONTEXT_TYPE:
							case REACT_FORWARD_REF_TYPE:
							case REACT_LAZY_TYPE:
							case REACT_MEMO_TYPE: return object;
							case REACT_CONSUMER_TYPE: return object;
							default: return $$typeof;
						}
					}
					case REACT_PORTAL_TYPE: return $$typeof;
				}
			}
		}
		var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
		exports.ContextConsumer = REACT_CONSUMER_TYPE;
		exports.ContextProvider = REACT_CONTEXT_TYPE;
		exports.Element = REACT_ELEMENT_TYPE;
		exports.ForwardRef = REACT_FORWARD_REF_TYPE;
		exports.Fragment = REACT_FRAGMENT_TYPE;
		exports.Lazy = REACT_LAZY_TYPE;
		exports.Memo = REACT_MEMO_TYPE;
		exports.Portal = REACT_PORTAL_TYPE;
		exports.Profiler = REACT_PROFILER_TYPE;
		exports.StrictMode = REACT_STRICT_MODE_TYPE;
		exports.Suspense = REACT_SUSPENSE_TYPE;
		exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
		exports.isContextConsumer = function(object) {
			return typeOf(object) === REACT_CONSUMER_TYPE;
		};
		exports.isContextProvider = function(object) {
			return typeOf(object) === REACT_CONTEXT_TYPE;
		};
		exports.isElement = function(object) {
			return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
		};
		exports.isForwardRef = function(object) {
			return typeOf(object) === REACT_FORWARD_REF_TYPE;
		};
		exports.isFragment = function(object) {
			return typeOf(object) === REACT_FRAGMENT_TYPE;
		};
		exports.isLazy = function(object) {
			return typeOf(object) === REACT_LAZY_TYPE;
		};
		exports.isMemo = function(object) {
			return typeOf(object) === REACT_MEMO_TYPE;
		};
		exports.isPortal = function(object) {
			return typeOf(object) === REACT_PORTAL_TYPE;
		};
		exports.isProfiler = function(object) {
			return typeOf(object) === REACT_PROFILER_TYPE;
		};
		exports.isStrictMode = function(object) {
			return typeOf(object) === REACT_STRICT_MODE_TYPE;
		};
		exports.isSuspense = function(object) {
			return typeOf(object) === REACT_SUSPENSE_TYPE;
		};
		exports.isSuspenseList = function(object) {
			return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
		};
		exports.isValidElementType = function(type) {
			return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? !0 : !1;
		};
		exports.typeOf = typeOf;
	})();
}) });

//#endregion
//#region node_modules/@mui/utils/node_modules/react-is/index.js
var require_react_is = /* @__PURE__ */ __commonJS({ "node_modules/@mui/utils/node_modules/react-is/index.js": ((exports, module) => {
	module.exports = require_react_is_development();
}) });

//#endregion
//#region node_modules/@mui/utils/esm/deepmerge/deepmerge.js
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var import_react_is$1 = /* @__PURE__ */ __toESM(require_react_is(), 1);
function isPlainObject(item) {
	if (typeof item !== "object" || item === null) return false;
	const prototype = Object.getPrototypeOf(item);
	return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
	if (/* @__PURE__ */ import_react.isValidElement(source) || (0, import_react_is$1.isValidElementType)(source) || !isPlainObject(source)) return source;
	const output = {};
	Object.keys(source).forEach((key) => {
		output[key] = deepClone(source[key]);
	});
	return output;
}
/**
* Merge objects deeply.
* It will shallow copy React elements.
*
* If `options.clone` is set to `false` the source object will be merged directly into the target object.
*
* @example
* ```ts
* deepmerge({ a: { b: 1 }, d: 2 }, { a: { c: 2 }, d: 4 });
* // => { a: { b: 1, c: 2 }, d: 4 }
* ````
*
* @param target The target object.
* @param source The source object.
* @param options The merge options.
* @param options.clone Set to `false` to merge the source object directly into the target object.
* @returns The merged object.
*/
function deepmerge(target, source, options = { clone: true }) {
	const output = options.clone ? { ...target } : target;
	if (isPlainObject(target) && isPlainObject(source)) Object.keys(source).forEach((key) => {
		if (/* @__PURE__ */ import_react.isValidElement(source[key]) || (0, import_react_is$1.isValidElementType)(source[key])) output[key] = source[key];
		else if (isPlainObject(source[key]) && Object.prototype.hasOwnProperty.call(target, key) && isPlainObject(target[key])) output[key] = deepmerge(target[key], source[key], options);
		else if (options.clone) output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
		else output[key] = source[key];
	});
	return output;
}

//#endregion
//#region node_modules/@mui/system/esm/merge/merge.js
function merge(acc, item) {
	if (!item) return acc;
	return deepmerge(acc, item, { clone: false });
}
var merge_default = merge;

//#endregion
//#region node_modules/@mui/system/esm/responsivePropType/responsivePropType.js
var import_prop_types$1 = /* @__PURE__ */ __toESM(require_prop_types(), 1);
var responsivePropType = import_prop_types$1.default.oneOfType([
	import_prop_types$1.default.number,
	import_prop_types$1.default.string,
	import_prop_types$1.default.object,
	import_prop_types$1.default.array
]);
var responsivePropType_default = responsivePropType;

//#endregion
//#region node_modules/@mui/system/esm/cssContainerQueries/cssContainerQueries.js
/**
* For using in `sx` prop to sort the breakpoint from low to high.
* Note: this function does not work and will not support multiple units.
*       e.g. input: { '@container (min-width:300px)': '1rem', '@container (min-width:40rem)': '2rem' }
*            output: { '@container (min-width:40rem)': '2rem', '@container (min-width:300px)': '1rem' } // since 40 < 300 even though 40rem > 300px
*/
function sortContainerQueries(theme, css$1) {
	if (!theme.containerQueries) return css$1;
	const sorted = Object.keys(css$1).filter((key) => key.startsWith("@container")).sort((a, b) => {
		const regex = /min-width:\s*([0-9.]+)/;
		return +(a.match(regex)?.[1] || 0) - +(b.match(regex)?.[1] || 0);
	});
	if (!sorted.length) return css$1;
	return sorted.reduce((acc, key) => {
		const value = css$1[key];
		delete acc[key];
		acc[key] = value;
		return acc;
	}, { ...css$1 });
}
function isCqShorthand(breakpointKeys, value) {
	return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme, shorthand) {
	const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
	if (!matches) throw new Error(`MUI: The provided shorthand ${`(${shorthand})`} is invalid. The format should be \`@<breakpoint | number>\` or \`@<breakpoint | number>/<container>\`.\nFor example, \`@sm\` or \`@600\` or \`@40rem/sidebar\`.`);
	const [, containerQuery, containerName] = matches;
	const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
	return theme.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
	const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
	function attachCq(node$1, name) {
		node$1.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
		node$1.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
		node$1.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
		node$1.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
		node$1.not = (...args) => {
			const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
			if (result.includes("not all and")) return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
			return result;
		};
	}
	const node = {};
	const containerQueries = (name) => {
		attachCq(node, name);
		return node;
	};
	attachCq(containerQueries);
	return {
		...themeInput,
		containerQueries
	};
}

//#endregion
//#region node_modules/@mui/system/esm/breakpoints/breakpoints.js
var import_prop_types = /* @__PURE__ */ __toESM(require_prop_types(), 1);
const values = {
	xs: 0,
	sm: 600,
	md: 900,
	lg: 1200,
	xl: 1536
};
var defaultBreakpoints = {
	keys: [
		"xs",
		"sm",
		"md",
		"lg",
		"xl"
	],
	up: (key) => `@media (min-width:${values[key]}px)`
};
var defaultContainerQueries = { containerQueries: (containerName) => ({ up: (key) => {
	let result = typeof key === "number" ? key : values[key] || key;
	if (typeof result === "number") result = `${result}px`;
	return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
} }) };
function handleBreakpoints(props, propValue, styleFromPropValue) {
	const theme = props.theme || {};
	if (Array.isArray(propValue)) {
		const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
		return propValue.reduce((acc, item, index) => {
			acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
			return acc;
		}, {});
	}
	if (typeof propValue === "object") {
		const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
		return Object.keys(propValue).reduce((acc, breakpoint) => {
			if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
				const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
				if (containerKey) acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
			} else if (Object.keys(themeBreakpoints.values || values).includes(breakpoint)) {
				const mediaKey = themeBreakpoints.up(breakpoint);
				acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
			} else {
				const cssKey = breakpoint;
				acc[cssKey] = propValue[cssKey];
			}
			return acc;
		}, {});
	}
	return styleFromPropValue(propValue);
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
	return breakpointsInput.keys?.reduce((acc, key) => {
		const breakpointStyleKey = breakpointsInput.up(key);
		acc[breakpointStyleKey] = {};
		return acc;
	}, {}) || {};
}
function removeUnusedBreakpoints(breakpointKeys, style$2) {
	return breakpointKeys.reduce((acc, key) => {
		const breakpointOutput = acc[key];
		if (!breakpointOutput || Object.keys(breakpointOutput).length === 0) delete acc[key];
		return acc;
	}, style$2);
}

//#endregion
//#region node_modules/@mui/system/esm/style/style.js
function getPath(obj, path, checkVars = true) {
	if (!path || typeof path !== "string") return null;
	if (obj && obj.vars && checkVars) {
		const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
		if (val != null) return val;
	}
	return path.split(".").reduce((acc, item) => {
		if (acc && acc[item] != null) return acc[item];
		return null;
	}, obj);
}
function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
	let value;
	if (typeof themeMapping === "function") value = themeMapping(propValueFinal);
	else if (Array.isArray(themeMapping)) value = themeMapping[propValueFinal] || userValue;
	else value = getPath(themeMapping, propValueFinal) || userValue;
	if (transform) value = transform(value, userValue, themeMapping);
	return value;
}
function style$1(options) {
	const { prop, cssProperty = options.prop, themeKey, transform } = options;
	const fn = (props) => {
		if (props[prop] == null) return null;
		const propValue = props[prop];
		const theme = props.theme;
		const themeMapping = getPath(theme, themeKey) || {};
		const styleFromPropValue = (propValueFinal) => {
			let value = getStyleValue(themeMapping, transform, propValueFinal);
			if (propValueFinal === value && typeof propValueFinal === "string") value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
			if (cssProperty === false) return value;
			return { [cssProperty]: value };
		};
		return handleBreakpoints(props, propValue, styleFromPropValue);
	};
	fn.propTypes = { [prop]: responsivePropType_default };
	fn.filterProps = [prop];
	return fn;
}
var style_default = style$1;

//#endregion
//#region node_modules/@mui/system/esm/memoize/memoize.js
function memoize$1(fn) {
	const cache = {};
	return (arg$1) => {
		if (cache[arg$1] === void 0) cache[arg$1] = fn(arg$1);
		return cache[arg$1];
	};
}

//#endregion
//#region node_modules/@mui/system/esm/spacing/spacing.js
var properties = {
	m: "margin",
	p: "padding"
};
var directions = {
	t: "Top",
	r: "Right",
	b: "Bottom",
	l: "Left",
	x: ["Left", "Right"],
	y: ["Top", "Bottom"]
};
var aliases = {
	marginX: "mx",
	marginY: "my",
	paddingX: "px",
	paddingY: "py"
};
var getCssProperties = memoize$1((prop) => {
	if (prop.length > 2) if (aliases[prop]) prop = aliases[prop];
	else return [prop];
	const [a, b] = prop.split("");
	const property = properties[a];
	const direction = directions[b] || "";
	return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = [
	"m",
	"mt",
	"mr",
	"mb",
	"ml",
	"mx",
	"my",
	"margin",
	"marginTop",
	"marginRight",
	"marginBottom",
	"marginLeft",
	"marginX",
	"marginY",
	"marginInline",
	"marginInlineStart",
	"marginInlineEnd",
	"marginBlock",
	"marginBlockStart",
	"marginBlockEnd"
];
const paddingKeys = [
	"p",
	"pt",
	"pr",
	"pb",
	"pl",
	"px",
	"py",
	"padding",
	"paddingTop",
	"paddingRight",
	"paddingBottom",
	"paddingLeft",
	"paddingX",
	"paddingY",
	"paddingInline",
	"paddingInlineStart",
	"paddingInlineEnd",
	"paddingBlock",
	"paddingBlockStart",
	"paddingBlockEnd"
];
var spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
	const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
	if (typeof themeSpacing === "number" || typeof themeSpacing === "string") return (val) => {
		if (typeof val === "string") return val;
		if (typeof val !== "number") console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${val}.`);
		if (typeof themeSpacing === "string") {
			if (themeSpacing.startsWith("var(") && val === 0) return 0;
			if (themeSpacing.startsWith("var(") && val === 1) return themeSpacing;
			return `calc(${val} * ${themeSpacing})`;
		}
		return themeSpacing * val;
	};
	if (Array.isArray(themeSpacing)) return (val) => {
		if (typeof val === "string") return val;
		const abs = Math.abs(val);
		if (!Number.isInteger(abs)) console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join("\n"));
		else if (abs > themeSpacing.length - 1) console.error([
			`MUI: The value provided (${abs}) overflows.`,
			`The supported values are: ${JSON.stringify(themeSpacing)}.`,
			`${abs} > ${themeSpacing.length - 1}, you need to add the missing values.`
		].join("\n"));
		const transformed = themeSpacing[abs];
		if (val >= 0) return transformed;
		if (typeof transformed === "number") return -transformed;
		if (typeof transformed === "string" && transformed.startsWith("var(")) return `calc(-1 * ${transformed})`;
		return `-${transformed}`;
	};
	if (typeof themeSpacing === "function") return themeSpacing;
	console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, "It should be a number, an array or a function."].join("\n"));
	return () => void 0;
}
function createUnarySpacing(theme) {
	return createUnaryUnit(theme, "spacing", 8, "spacing");
}
function getValue(transformer, propValue) {
	if (typeof propValue === "string" || propValue == null) return propValue;
	return transformer(propValue);
}
function getStyleFromPropValue(cssProperties, transformer) {
	return (propValue) => cssProperties.reduce((acc, cssProperty) => {
		acc[cssProperty] = getValue(transformer, propValue);
		return acc;
	}, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
	if (!keys.includes(prop)) return null;
	const cssProperties = getCssProperties(prop);
	const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
	const propValue = props[prop];
	return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys) {
	const transformer = createUnarySpacing(props.theme);
	return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge_default, {});
}
function margin(props) {
	return style(props, marginKeys);
}
margin.propTypes = marginKeys.reduce((obj, key) => {
	obj[key] = responsivePropType_default;
	return obj;
}, {});
margin.filterProps = marginKeys;
function padding(props) {
	return style(props, paddingKeys);
}
padding.propTypes = paddingKeys.reduce((obj, key) => {
	obj[key] = responsivePropType_default;
	return obj;
}, {});
padding.filterProps = paddingKeys;
function spacing(props) {
	return style(props, spacingKeys);
}
spacing.propTypes = spacingKeys.reduce((obj, key) => {
	obj[key] = responsivePropType_default;
	return obj;
}, {});
spacing.filterProps = spacingKeys;

//#endregion
//#region node_modules/@mui/system/esm/compose/compose.js
function compose(...styles) {
	const handlers = styles.reduce((acc, style$2) => {
		style$2.filterProps.forEach((prop) => {
			acc[prop] = style$2;
		});
		return acc;
	}, {});
	const fn = (props) => {
		return Object.keys(props).reduce((acc, prop) => {
			if (handlers[prop]) return merge_default(acc, handlers[prop](props));
			return acc;
		}, {});
	};
	fn.propTypes = styles.reduce((acc, style$2) => Object.assign(acc, style$2.propTypes), {});
	fn.filterProps = styles.reduce((acc, style$2) => acc.concat(style$2.filterProps), []);
	return fn;
}
var compose_default = compose;

//#endregion
//#region node_modules/@mui/system/esm/borders/borders.js
function borderTransform(value) {
	if (typeof value !== "number") return value;
	return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
	return style_default({
		prop,
		themeKey: "borders",
		transform
	});
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
	if (props.borderRadius !== void 0 && props.borderRadius !== null) {
		const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4, "borderRadius");
		const styleFromPropValue = (propValue) => ({ borderRadius: getValue(transformer, propValue) });
		return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
	}
	return null;
};
borderRadius.propTypes = { borderRadius: responsivePropType_default };
borderRadius.filterProps = ["borderRadius"];
var borders = compose_default(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);

//#endregion
//#region node_modules/@mui/system/esm/cssGrid/cssGrid.js
const gap = (props) => {
	if (props.gap !== void 0 && props.gap !== null) {
		const transformer = createUnaryUnit(props.theme, "spacing", 8, "gap");
		const styleFromPropValue = (propValue) => ({ gap: getValue(transformer, propValue) });
		return handleBreakpoints(props, props.gap, styleFromPropValue);
	}
	return null;
};
gap.propTypes = { gap: responsivePropType_default };
gap.filterProps = ["gap"];
const columnGap = (props) => {
	if (props.columnGap !== void 0 && props.columnGap !== null) {
		const transformer = createUnaryUnit(props.theme, "spacing", 8, "columnGap");
		const styleFromPropValue = (propValue) => ({ columnGap: getValue(transformer, propValue) });
		return handleBreakpoints(props, props.columnGap, styleFromPropValue);
	}
	return null;
};
columnGap.propTypes = { columnGap: responsivePropType_default };
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
	if (props.rowGap !== void 0 && props.rowGap !== null) {
		const transformer = createUnaryUnit(props.theme, "spacing", 8, "rowGap");
		const styleFromPropValue = (propValue) => ({ rowGap: getValue(transformer, propValue) });
		return handleBreakpoints(props, props.rowGap, styleFromPropValue);
	}
	return null;
};
rowGap.propTypes = { rowGap: responsivePropType_default };
rowGap.filterProps = ["rowGap"];
const gridColumn = style_default({ prop: "gridColumn" });
const gridRow = style_default({ prop: "gridRow" });
const gridAutoFlow = style_default({ prop: "gridAutoFlow" });
const gridAutoColumns = style_default({ prop: "gridAutoColumns" });
const gridAutoRows = style_default({ prop: "gridAutoRows" });
const gridTemplateColumns = style_default({ prop: "gridTemplateColumns" });
const gridTemplateRows = style_default({ prop: "gridTemplateRows" });
const gridTemplateAreas = style_default({ prop: "gridTemplateAreas" });
const gridArea = style_default({ prop: "gridArea" });
var grid = compose_default(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);

//#endregion
//#region node_modules/@mui/system/esm/palette/palette.js
function paletteTransform(value, userValue) {
	if (userValue === "grey") return userValue;
	return value;
}
const color = style_default({
	prop: "color",
	themeKey: "palette",
	transform: paletteTransform
});
const bgcolor = style_default({
	prop: "bgcolor",
	cssProperty: "backgroundColor",
	themeKey: "palette",
	transform: paletteTransform
});
const backgroundColor = style_default({
	prop: "backgroundColor",
	themeKey: "palette",
	transform: paletteTransform
});
var palette = compose_default(color, bgcolor, backgroundColor);

//#endregion
//#region node_modules/@mui/system/esm/sizing/sizing.js
function sizingTransform(value) {
	return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style_default({
	prop: "width",
	transform: sizingTransform
});
const maxWidth = (props) => {
	if (props.maxWidth !== void 0 && props.maxWidth !== null) {
		const styleFromPropValue = (propValue) => {
			const breakpoint = props.theme?.breakpoints?.values?.[propValue] || values[propValue];
			if (!breakpoint) return { maxWidth: sizingTransform(propValue) };
			if (props.theme?.breakpoints?.unit !== "px") return { maxWidth: `${breakpoint}${props.theme.breakpoints.unit}` };
			return { maxWidth: breakpoint };
		};
		return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
	}
	return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style_default({
	prop: "minWidth",
	transform: sizingTransform
});
const height = style_default({
	prop: "height",
	transform: sizingTransform
});
const maxHeight = style_default({
	prop: "maxHeight",
	transform: sizingTransform
});
const minHeight = style_default({
	prop: "minHeight",
	transform: sizingTransform
});
const sizeWidth = style_default({
	prop: "size",
	cssProperty: "width",
	transform: sizingTransform
});
const sizeHeight = style_default({
	prop: "size",
	cssProperty: "height",
	transform: sizingTransform
});
const boxSizing = style_default({ prop: "boxSizing" });
var sizing = compose_default(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);

//#endregion
//#region node_modules/@mui/system/esm/styleFunctionSx/defaultSxConfig.js
var defaultSxConfig = {
	border: {
		themeKey: "borders",
		transform: borderTransform
	},
	borderTop: {
		themeKey: "borders",
		transform: borderTransform
	},
	borderRight: {
		themeKey: "borders",
		transform: borderTransform
	},
	borderBottom: {
		themeKey: "borders",
		transform: borderTransform
	},
	borderLeft: {
		themeKey: "borders",
		transform: borderTransform
	},
	borderColor: { themeKey: "palette" },
	borderTopColor: { themeKey: "palette" },
	borderRightColor: { themeKey: "palette" },
	borderBottomColor: { themeKey: "palette" },
	borderLeftColor: { themeKey: "palette" },
	outline: {
		themeKey: "borders",
		transform: borderTransform
	},
	outlineColor: { themeKey: "palette" },
	borderRadius: {
		themeKey: "shape.borderRadius",
		style: borderRadius
	},
	color: {
		themeKey: "palette",
		transform: paletteTransform
	},
	bgcolor: {
		themeKey: "palette",
		cssProperty: "backgroundColor",
		transform: paletteTransform
	},
	backgroundColor: {
		themeKey: "palette",
		transform: paletteTransform
	},
	p: { style: padding },
	pt: { style: padding },
	pr: { style: padding },
	pb: { style: padding },
	pl: { style: padding },
	px: { style: padding },
	py: { style: padding },
	padding: { style: padding },
	paddingTop: { style: padding },
	paddingRight: { style: padding },
	paddingBottom: { style: padding },
	paddingLeft: { style: padding },
	paddingX: { style: padding },
	paddingY: { style: padding },
	paddingInline: { style: padding },
	paddingInlineStart: { style: padding },
	paddingInlineEnd: { style: padding },
	paddingBlock: { style: padding },
	paddingBlockStart: { style: padding },
	paddingBlockEnd: { style: padding },
	m: { style: margin },
	mt: { style: margin },
	mr: { style: margin },
	mb: { style: margin },
	ml: { style: margin },
	mx: { style: margin },
	my: { style: margin },
	margin: { style: margin },
	marginTop: { style: margin },
	marginRight: { style: margin },
	marginBottom: { style: margin },
	marginLeft: { style: margin },
	marginX: { style: margin },
	marginY: { style: margin },
	marginInline: { style: margin },
	marginInlineStart: { style: margin },
	marginInlineEnd: { style: margin },
	marginBlock: { style: margin },
	marginBlockStart: { style: margin },
	marginBlockEnd: { style: margin },
	displayPrint: {
		cssProperty: false,
		transform: (value) => ({ "@media print": { display: value } })
	},
	display: {},
	overflow: {},
	textOverflow: {},
	visibility: {},
	whiteSpace: {},
	flexBasis: {},
	flexDirection: {},
	flexWrap: {},
	justifyContent: {},
	alignItems: {},
	alignContent: {},
	order: {},
	flex: {},
	flexGrow: {},
	flexShrink: {},
	alignSelf: {},
	justifyItems: {},
	justifySelf: {},
	gap: { style: gap },
	rowGap: { style: rowGap },
	columnGap: { style: columnGap },
	gridColumn: {},
	gridRow: {},
	gridAutoFlow: {},
	gridAutoColumns: {},
	gridAutoRows: {},
	gridTemplateColumns: {},
	gridTemplateRows: {},
	gridTemplateAreas: {},
	gridArea: {},
	position: {},
	zIndex: { themeKey: "zIndex" },
	top: {},
	right: {},
	bottom: {},
	left: {},
	boxShadow: { themeKey: "shadows" },
	width: { transform: sizingTransform },
	maxWidth: { style: maxWidth },
	minWidth: { transform: sizingTransform },
	height: { transform: sizingTransform },
	maxHeight: { transform: sizingTransform },
	minHeight: { transform: sizingTransform },
	boxSizing: {},
	font: { themeKey: "font" },
	fontFamily: { themeKey: "typography" },
	fontSize: { themeKey: "typography" },
	fontStyle: { themeKey: "typography" },
	fontWeight: { themeKey: "typography" },
	letterSpacing: {},
	textTransform: {},
	lineHeight: {},
	textAlign: {},
	typography: {
		cssProperty: false,
		themeKey: "typography"
	}
};
var defaultSxConfig_default = defaultSxConfig;

//#endregion
//#region node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js
function objectsHaveSameKeys(...objects) {
	const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
	const union = new Set(allKeys);
	return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg$1) {
	return typeof maybeFn === "function" ? maybeFn(arg$1) : maybeFn;
}
function unstable_createStyleFunctionSx() {
	function getThemeValue(prop, val, theme, config) {
		const props = {
			[prop]: val,
			theme
		};
		const options = config[prop];
		if (!options) return { [prop]: val };
		const { cssProperty = prop, themeKey, transform, style: style$2 } = options;
		if (val == null) return null;
		if (themeKey === "typography" && val === "inherit") return { [prop]: val };
		const themeMapping = getPath(theme, themeKey) || {};
		if (style$2) return style$2(props);
		const styleFromPropValue = (propValueFinal) => {
			let value = getStyleValue(themeMapping, transform, propValueFinal);
			if (propValueFinal === value && typeof propValueFinal === "string") value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
			if (cssProperty === false) return value;
			return { [cssProperty]: value };
		};
		return handleBreakpoints(props, val, styleFromPropValue);
	}
	function styleFunctionSx$1(props) {
		const { sx, theme = {}, nested } = props || {};
		if (!sx) return null;
		const config = theme.unstable_sxConfig ?? defaultSxConfig_default;
		function traverse(sxInput) {
			let sxObject = sxInput;
			if (typeof sxInput === "function") sxObject = sxInput(theme);
			else if (typeof sxInput !== "object") return sxInput;
			if (!sxObject) return null;
			const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
			const breakpointsKeys = Object.keys(emptyBreakpoints);
			let css$1 = emptyBreakpoints;
			Object.keys(sxObject).forEach((styleKey) => {
				const value = callIfFn(sxObject[styleKey], theme);
				if (value !== null && value !== void 0) if (typeof value === "object") if (config[styleKey]) css$1 = merge_default(css$1, getThemeValue(styleKey, value, theme, config));
				else {
					const breakpointsValues = handleBreakpoints({ theme }, value, (x) => ({ [styleKey]: x }));
					if (objectsHaveSameKeys(breakpointsValues, value)) css$1[styleKey] = styleFunctionSx$1({
						sx: value,
						theme,
						nested: true
					});
					else css$1 = merge_default(css$1, breakpointsValues);
				}
				else css$1 = merge_default(css$1, getThemeValue(styleKey, value, theme, config));
			});
			if (!nested && theme.modularCssLayers) return { "@layer sx": sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css$1)) };
			return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css$1));
		}
		return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
	}
	return styleFunctionSx$1;
}
var styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
var styleFunctionSx_default = styleFunctionSx;

//#endregion
//#region node_modules/@mui/system/esm/styleFunctionSx/extendSxProp.js
var splitProps = (props) => {
	const result = {
		systemProps: {},
		otherProps: {}
	};
	const config = props?.theme?.unstable_sxConfig ?? defaultSxConfig_default;
	Object.keys(props).forEach((prop) => {
		if (config[prop]) result.systemProps[prop] = props[prop];
		else result.otherProps[prop] = props[prop];
	});
	return result;
};
function extendSxProp(props) {
	const { sx: inSx,...other } = props;
	const { systemProps, otherProps } = splitProps(other);
	let finalSx;
	if (Array.isArray(inSx)) finalSx = [systemProps, ...inSx];
	else if (typeof inSx === "function") finalSx = (...args) => {
		const result = inSx(...args);
		if (!isPlainObject(result)) return systemProps;
		return {
			...systemProps,
			...result
		};
	};
	else finalSx = {
		...systemProps,
		...inSx
	};
	return {
		...otherProps,
		sx: finalSx
	};
}

//#endregion
//#region node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize(function(prop) {
	return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
});

//#endregion
//#region node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.development.esm.js
var isDevelopment = true;
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent$1(key) {
	return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp$1(tag) {
	return typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps$1(tag, options, isReal) {
	var shouldForwardProp$1;
	if (options) {
		var optionsShouldForwardProp = options.shouldForwardProp;
		shouldForwardProp$1 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
			return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
		} : optionsShouldForwardProp;
	}
	if (typeof shouldForwardProp$1 !== "function" && isReal) shouldForwardProp$1 = tag.__emotion_forwardProp;
	return shouldForwardProp$1;
};
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var Insertion = function Insertion$1(_ref) {
	var cache = _ref.cache, serialized = _ref.serialized, isStringTag$1 = _ref.isStringTag;
	registerStyles(cache, serialized, isStringTag$1);
	useInsertionEffectAlwaysWithSyncFallback(function() {
		return insertStyles(cache, serialized, isStringTag$1);
	});
	return null;
};
var createStyled$1 = function createStyled$2(tag, options) {
	if (tag === void 0) throw new Error("You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.");
	var isReal = tag.__emotion_real === tag;
	var baseTag = isReal && tag.__emotion_base || tag;
	var identifierName;
	var targetClassName;
	if (options !== void 0) {
		identifierName = options.label;
		targetClassName = options.target;
	}
	var shouldForwardProp$1 = composeShouldForwardProps(tag, options, isReal);
	var defaultShouldForwardProp = shouldForwardProp$1 || getDefaultShouldForwardProp(baseTag);
	var shouldUseAs = !defaultShouldForwardProp("as");
	return function() {
		var args = arguments;
		var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
		if (identifierName !== void 0) styles.push("label:" + identifierName + ";");
		if (args[0] == null || args[0].raw === void 0) styles.push.apply(styles, args);
		else {
			var templateStringsArr = args[0];
			if (templateStringsArr[0] === void 0) console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
			styles.push(templateStringsArr[0]);
			var len = args.length;
			var i = 1;
			for (; i < len; i++) {
				if (templateStringsArr[i] === void 0) console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
				styles.push(args[i], templateStringsArr[i]);
			}
		}
		var Styled = withEmotionCache(function(props, cache, ref) {
			var FinalTag = shouldUseAs && props.as || baseTag;
			var className = "";
			var classInterpolations = [];
			var mergedProps = props;
			if (props.theme == null) {
				mergedProps = {};
				for (var key in props) mergedProps[key] = props[key];
				mergedProps.theme = import_react.useContext(ThemeContext);
			}
			if (typeof props.className === "string") className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
			else if (props.className != null) className = props.className + " ";
			var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
			className += cache.key + "-" + serialized.name;
			if (targetClassName !== void 0) className += " " + targetClassName;
			var finalShouldForwardProp = shouldUseAs && shouldForwardProp$1 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
			var newProps = {};
			for (var _key in props) {
				if (shouldUseAs && _key === "as") continue;
				if (finalShouldForwardProp(_key)) newProps[_key] = props[_key];
			}
			newProps.className = className;
			if (ref) newProps.ref = ref;
			return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Insertion, {
				cache,
				serialized,
				isStringTag: typeof FinalTag === "string"
			}), /* @__PURE__ */ import_react.createElement(FinalTag, newProps));
		});
		Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
		Styled.defaultProps = tag.defaultProps;
		Styled.__emotion_real = Styled;
		Styled.__emotion_base = baseTag;
		Styled.__emotion_styles = styles;
		Styled.__emotion_forwardProp = shouldForwardProp$1;
		Object.defineProperty(Styled, "toString", { value: function value() {
			if (targetClassName === void 0 && isDevelopment) return "NO_COMPONENT_SELECTOR";
			return "." + targetClassName;
		} });
		Styled.withComponent = function(nextTag, nextOptions) {
			return createStyled$2(nextTag, _extends({}, options, nextOptions, { shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true) })).apply(void 0, styles);
		};
		return Styled;
	};
};

//#endregion
//#region node_modules/@emotion/styled/dist/emotion-styled.browser.development.esm.js
var tags = [
	"a",
	"abbr",
	"address",
	"area",
	"article",
	"aside",
	"audio",
	"b",
	"base",
	"bdi",
	"bdo",
	"big",
	"blockquote",
	"body",
	"br",
	"button",
	"canvas",
	"caption",
	"cite",
	"code",
	"col",
	"colgroup",
	"data",
	"datalist",
	"dd",
	"del",
	"details",
	"dfn",
	"dialog",
	"div",
	"dl",
	"dt",
	"em",
	"embed",
	"fieldset",
	"figcaption",
	"figure",
	"footer",
	"form",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"head",
	"header",
	"hgroup",
	"hr",
	"html",
	"i",
	"iframe",
	"img",
	"input",
	"ins",
	"kbd",
	"keygen",
	"label",
	"legend",
	"li",
	"link",
	"main",
	"map",
	"mark",
	"marquee",
	"menu",
	"menuitem",
	"meta",
	"meter",
	"nav",
	"noscript",
	"object",
	"ol",
	"optgroup",
	"option",
	"output",
	"p",
	"param",
	"picture",
	"pre",
	"progress",
	"q",
	"rp",
	"rt",
	"ruby",
	"s",
	"samp",
	"script",
	"section",
	"select",
	"small",
	"source",
	"span",
	"strong",
	"style",
	"sub",
	"summary",
	"sup",
	"table",
	"tbody",
	"td",
	"textarea",
	"tfoot",
	"th",
	"thead",
	"time",
	"title",
	"tr",
	"track",
	"u",
	"ul",
	"var",
	"video",
	"wbr",
	"circle",
	"clipPath",
	"defs",
	"ellipse",
	"foreignObject",
	"g",
	"image",
	"line",
	"linearGradient",
	"mask",
	"path",
	"pattern",
	"polygon",
	"polyline",
	"radialGradient",
	"rect",
	"stop",
	"svg",
	"text",
	"tspan"
];
var styled$2 = createStyled$1.bind(null);
tags.forEach(function(tagName) {
	styled$2[tagName] = styled$2(tagName);
});

//#endregion
//#region node_modules/@mui/styled-engine/esm/index.js
function styled$1(tag, options) {
	const stylesFactory = styled$2(tag, options);
	return (...styles) => {
		const component = typeof tag === "string" ? `"${tag}"` : "component";
		if (styles.length === 0) console.error([`MUI: Seems like you called \`styled(${component})()\` without a \`style\` argument.`, "You must provide a `styles` argument: `styled(\"div\")(styleYouForgotToPass)`."].join("\n"));
		else if (styles.some((style$2) => style$2 === void 0)) console.error(`MUI: the styled(${component})(...args) API requires all its args to be defined.`);
		return stylesFactory(...styles);
	};
}
function internal_mutateStyles(tag, processor) {
	if (Array.isArray(tag.__emotion_styles)) tag.__emotion_styles = processor(tag.__emotion_styles);
}
var wrapper = [];
function internal_serializeStyles(styles) {
	wrapper[0] = styles;
	return serializeStyles(wrapper);
}

//#endregion
//#region node_modules/@mui/system/esm/createBreakpoints/createBreakpoints.js
var sortBreakpointsValues = (values$1) => {
	const breakpointsAsArray = Object.keys(values$1).map((key) => ({
		key,
		val: values$1[key]
	})) || [];
	breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
	return breakpointsAsArray.reduce((acc, obj) => {
		return {
			...acc,
			[obj.key]: obj.val
		};
	}, {});
};
function createBreakpoints(breakpoints) {
	const { values: values$1 = {
		xs: 0,
		sm: 600,
		md: 900,
		lg: 1200,
		xl: 1536
	}, unit = "px", step = 5,...other } = breakpoints;
	const sortedValues = sortBreakpointsValues(values$1);
	const keys = Object.keys(sortedValues);
	function up(key) {
		return `@media (min-width:${typeof values$1[key] === "number" ? values$1[key] : key}${unit})`;
	}
	function down(key) {
		return `@media (max-width:${(typeof values$1[key] === "number" ? values$1[key] : key) - step / 100}${unit})`;
	}
	function between(start, end) {
		const endIndex = keys.indexOf(end);
		return `@media (min-width:${typeof values$1[start] === "number" ? values$1[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values$1[keys[endIndex]] === "number" ? values$1[keys[endIndex]] : end) - step / 100}${unit})`;
	}
	function only(key) {
		if (keys.indexOf(key) + 1 < keys.length) return between(key, keys[keys.indexOf(key) + 1]);
		return up(key);
	}
	function not(key) {
		const keyIndex = keys.indexOf(key);
		if (keyIndex === 0) return up(keys[1]);
		if (keyIndex === keys.length - 1) return down(keys[keyIndex]);
		return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
	}
	return {
		keys,
		values: sortedValues,
		up,
		down,
		between,
		only,
		not,
		unit,
		...other
	};
}

//#endregion
//#region node_modules/@mui/system/esm/createTheme/shape.js
var shape = { borderRadius: 4 };
var shape_default = shape;

//#endregion
//#region node_modules/@mui/system/esm/createTheme/createSpacing.js
function createSpacing(spacingInput = 8, transform = createUnarySpacing({ spacing: spacingInput })) {
	if (spacingInput.mui) return spacingInput;
	const spacing$1 = (...argsInput) => {
		if (!(argsInput.length <= 4)) console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`);
		return (argsInput.length === 0 ? [1] : argsInput).map((argument) => {
			const output = transform(argument);
			return typeof output === "number" ? `${output}px` : output;
		}).join(" ");
	};
	spacing$1.mui = true;
	return spacing$1;
}

//#endregion
//#region node_modules/@mui/system/esm/createTheme/applyStyles.js
/**
* A universal utility to style components with multiple color modes. Always use it from the theme object.
* It works with:
*  - [Basic theme](https://mui.com/material-ui/customization/dark-mode/)
*  - [CSS theme variables](https://mui.com/material-ui/customization/css-theme-variables/overview/)
*  - Zero-runtime engine
*
* Tips: Use an array over object spread and place `theme.applyStyles()` last.
*
* With the styled function:
*  [{ background: '#e5e5e5' }, theme.applyStyles('dark', { background: '#1c1c1c' })]
*  { background: '#e5e5e5', ...theme.applyStyles('dark', { background: '#1c1c1c' })}
*
* With the sx prop:
*  [{ background: '#e5e5e5' }, theme => theme.applyStyles('dark', { background: '#1c1c1c' })]
*  { background: '#e5e5e5', ...theme => theme.applyStyles('dark', { background: '#1c1c1c' })}
*
* @example
* 1. using with `styled`:
* ```jsx
*   const Component = styled('div')(({ theme }) => [
*     { background: '#e5e5e5' },
*     theme.applyStyles('dark', {
*       background: '#1c1c1c',
*       color: '#fff',
*     }),
*   ]);
* ```
*
* @example
* 2. using with `sx` prop:
* ```jsx
*   <Box sx={[
*     { background: '#e5e5e5' },
*     theme => theme.applyStyles('dark', {
*        background: '#1c1c1c',
*        color: '#fff',
*      }),
*     ]}
*   />
* ```
*
* @example
* 3. theming a component:
* ```jsx
*   extendTheme({
*     components: {
*       MuiButton: {
*         styleOverrides: {
*           root: ({ theme }) => [
*             { background: '#e5e5e5' },
*             theme.applyStyles('dark', {
*               background: '#1c1c1c',
*               color: '#fff',
*             }),
*           ],
*         },
*       }
*     }
*   })
*```
*/
function applyStyles(key, styles) {
	const theme = this;
	if (theme.vars) {
		if (!theme.colorSchemes?.[key] || typeof theme.getColorSchemeSelector !== "function") return {};
		let selector = theme.getColorSchemeSelector(key);
		if (selector === "&") return styles;
		if (selector.includes("data-") || selector.includes(".")) selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
		return { [selector]: styles };
	}
	if (theme.palette.mode === key) return styles;
	return {};
}

//#endregion
//#region node_modules/@mui/system/esm/createTheme/createTheme.js
function createTheme$1(options = {}, ...args) {
	const { breakpoints: breakpointsInput = {}, palette: paletteInput = {}, spacing: spacingInput, shape: shapeInput = {},...other } = options;
	const breakpoints = createBreakpoints(breakpointsInput);
	const spacing$1 = createSpacing(spacingInput);
	let muiTheme = deepmerge({
		breakpoints,
		direction: "ltr",
		components: {},
		palette: {
			mode: "light",
			...paletteInput
		},
		spacing: spacing$1,
		shape: {
			...shape_default,
			...shapeInput
		}
	}, other);
	muiTheme = cssContainerQueries(muiTheme);
	muiTheme.applyStyles = applyStyles;
	muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
	muiTheme.unstable_sxConfig = {
		...defaultSxConfig_default,
		...other?.unstable_sxConfig
	};
	muiTheme.unstable_sx = function sx(props) {
		return styleFunctionSx_default({
			sx: props,
			theme: this
		});
	};
	return muiTheme;
}
var createTheme_default = createTheme$1;

//#endregion
//#region node_modules/@mui/system/esm/useThemeWithoutDefault/useThemeWithoutDefault.js
function isObjectEmpty$1(obj) {
	return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme$1 = null) {
	const contextTheme = import_react.useContext(ThemeContext);
	return !contextTheme || isObjectEmpty$1(contextTheme) ? defaultTheme$1 : contextTheme;
}
var useThemeWithoutDefault_default = useTheme$2;

//#endregion
//#region node_modules/@mui/system/esm/useTheme/useTheme.js
const systemDefaultTheme$1 = createTheme_default();
function useTheme$1(defaultTheme$1 = systemDefaultTheme$1) {
	return useThemeWithoutDefault_default(defaultTheme$1);
}
var useTheme_default = useTheme$1;

//#endregion
//#region node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js
const globalStateClasses = {
	active: "active",
	checked: "checked",
	completed: "completed",
	disabled: "disabled",
	error: "error",
	expanded: "expanded",
	focused: "focused",
	focusVisible: "focusVisible",
	open: "open",
	readOnly: "readOnly",
	required: "required",
	selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
	const globalStateClass = globalStateClasses[slot];
	return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator_default.generate(componentName)}-${slot}`;
}

//#endregion
//#region node_modules/@mui/utils/esm/getDisplayName/getDisplayName.js
var import_react_is = /* @__PURE__ */ __toESM(require_react_is(), 1);
function getFunctionComponentName(Component, fallback = "") {
	return Component.displayName || Component.name || fallback;
}
function getWrappedName(outerType, innerType, wrapperName) {
	const functionName = getFunctionComponentName(innerType);
	return outerType.displayName || (functionName !== "" ? `${wrapperName}(${functionName})` : wrapperName);
}
/**
* cherry-pick from
* https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/getComponentName.js
* originally forked from recompose/getDisplayName
*/
function getDisplayName(Component) {
	if (Component == null) return;
	if (typeof Component === "string") return Component;
	if (typeof Component === "function") return getFunctionComponentName(Component, "Component");
	if (typeof Component === "object") switch (Component.$$typeof) {
		case import_react_is.ForwardRef: return getWrappedName(Component, Component.render, "ForwardRef");
		case import_react_is.Memo: return getWrappedName(Component, Component.type, "memo");
		default: return;
	}
}

//#endregion
//#region node_modules/@mui/system/esm/preprocessStyles.js
function preprocessStyles(input) {
	const { variants,...style$2 } = input;
	const result = {
		variants,
		style: internal_serializeStyles(style$2),
		isProcessed: true
	};
	if (result.style === style$2) return result;
	if (variants) variants.forEach((variant) => {
		if (typeof variant.style !== "function") variant.style = internal_serializeStyles(variant.style);
	});
	return result;
}

//#endregion
//#region node_modules/@mui/system/esm/createStyled/createStyled.js
const systemDefaultTheme = createTheme_default();
function shouldForwardProp(prop) {
	return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function shallowLayer(serialized, layerName) {
	if (layerName && serialized && typeof serialized === "object" && serialized.styles && !serialized.styles.startsWith("@layer")) serialized.styles = `@layer ${layerName}{${String(serialized.styles)}}`;
	return serialized;
}
function defaultOverridesResolver(slot) {
	if (!slot) return null;
	return (_props, styles) => styles[slot];
}
function attachTheme(props, themeId, defaultTheme$1) {
	props.theme = isObjectEmpty(props.theme) ? defaultTheme$1 : props.theme[themeId] || props.theme;
}
function processStyle(props, style$2, layerName) {
	const resolvedStyle = typeof style$2 === "function" ? style$2(props) : style$2;
	if (Array.isArray(resolvedStyle)) return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle, layerName));
	if (Array.isArray(resolvedStyle?.variants)) {
		let rootStyle;
		if (resolvedStyle.isProcessed) rootStyle = layerName ? shallowLayer(resolvedStyle.style, layerName) : resolvedStyle.style;
		else {
			const { variants,...otherStyles } = resolvedStyle;
			rootStyle = layerName ? shallowLayer(internal_serializeStyles(otherStyles), layerName) : otherStyles;
		}
		return processStyleVariants(props, resolvedStyle.variants, [rootStyle], layerName);
	}
	if (resolvedStyle?.isProcessed) return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle.style), layerName) : resolvedStyle.style;
	return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle), layerName) : resolvedStyle;
}
function processStyleVariants(props, variants, results = [], layerName = void 0) {
	let mergedState;
	variantLoop: for (let i = 0; i < variants.length; i += 1) {
		const variant = variants[i];
		if (typeof variant.props === "function") {
			mergedState ??= {
				...props,
				...props.ownerState,
				ownerState: props.ownerState
			};
			if (!variant.props(mergedState)) continue;
		} else for (const key in variant.props) if (props[key] !== variant.props[key] && props.ownerState?.[key] !== variant.props[key]) continue variantLoop;
		if (typeof variant.style === "function") {
			mergedState ??= {
				...props,
				...props.ownerState,
				ownerState: props.ownerState
			};
			results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style(mergedState)), layerName) : variant.style(mergedState));
		} else results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style), layerName) : variant.style);
	}
	return results;
}
function createStyled(input = {}) {
	const { themeId, defaultTheme: defaultTheme$1 = systemDefaultTheme, rootShouldForwardProp: rootShouldForwardProp$1 = shouldForwardProp, slotShouldForwardProp: slotShouldForwardProp$1 = shouldForwardProp } = input;
	function styleAttachTheme(props) {
		attachTheme(props, themeId, defaultTheme$1);
	}
	const styled$3 = (tag, inputOptions = {}) => {
		internal_mutateStyles(tag, (styles) => styles.filter((style$2) => style$2 !== styleFunctionSx_default));
		const { name: componentName, slot: componentSlot, skipVariantsResolver: inputSkipVariantsResolver, skipSx: inputSkipSx, overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),...options } = inputOptions;
		const layerName = componentName && componentName.startsWith("Mui") || !!componentSlot ? "components" : "custom";
		const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false;
		const skipSx = inputSkipSx || false;
		let shouldForwardPropOption = shouldForwardProp;
		if (componentSlot === "Root" || componentSlot === "root") shouldForwardPropOption = rootShouldForwardProp$1;
		else if (componentSlot) shouldForwardPropOption = slotShouldForwardProp$1;
		else if (isStringTag(tag)) shouldForwardPropOption = void 0;
		const defaultStyledResolver = styled$1(tag, {
			shouldForwardProp: shouldForwardPropOption,
			label: generateStyledLabel(componentName, componentSlot),
			...options
		});
		const transformStyle = (style$2) => {
			if (style$2.__emotion_real === style$2) return style$2;
			if (typeof style$2 === "function") return function styleFunctionProcessor(props) {
				return processStyle(props, style$2, props.theme.modularCssLayers ? layerName : void 0);
			};
			if (isPlainObject(style$2)) {
				const serialized = preprocessStyles(style$2);
				return function styleObjectProcessor(props) {
					if (!serialized.variants) return props.theme.modularCssLayers ? shallowLayer(serialized.style, layerName) : serialized.style;
					return processStyle(props, serialized, props.theme.modularCssLayers ? layerName : void 0);
				};
			}
			return style$2;
		};
		const muiStyledResolver = (...expressionsInput) => {
			const expressionsHead = [];
			const expressionsBody = expressionsInput.map(transformStyle);
			const expressionsTail = [];
			expressionsHead.push(styleAttachTheme);
			if (componentName && overridesResolver) expressionsTail.push(function styleThemeOverrides(props) {
				const styleOverrides = props.theme.components?.[componentName]?.styleOverrides;
				if (!styleOverrides) return null;
				const resolvedStyleOverrides = {};
				for (const slotKey in styleOverrides) resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey], props.theme.modularCssLayers ? "theme" : void 0);
				return overridesResolver(props, resolvedStyleOverrides);
			});
			if (componentName && !skipVariantsResolver) expressionsTail.push(function styleThemeVariants(props) {
				const themeVariants = props.theme?.components?.[componentName]?.variants;
				if (!themeVariants) return null;
				return processStyleVariants(props, themeVariants, [], props.theme.modularCssLayers ? "theme" : void 0);
			});
			if (!skipSx) expressionsTail.push(styleFunctionSx_default);
			if (Array.isArray(expressionsBody[0])) {
				const inputStrings = expressionsBody.shift();
				const placeholdersHead = new Array(expressionsHead.length).fill("");
				const placeholdersTail = new Array(expressionsTail.length).fill("");
				let outputStrings;
				outputStrings = [
					...placeholdersHead,
					...inputStrings,
					...placeholdersTail
				];
				outputStrings.raw = [
					...placeholdersHead,
					...inputStrings.raw,
					...placeholdersTail
				];
				expressionsHead.unshift(outputStrings);
			}
			const expressions = [
				...expressionsHead,
				...expressionsBody,
				...expressionsTail
			];
			const Component = defaultStyledResolver(...expressions);
			if (tag.muiName) Component.muiName = tag.muiName;
			Component.displayName = generateDisplayName(componentName, componentSlot, tag);
			return Component;
		};
		if (defaultStyledResolver.withConfig) muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
		return muiStyledResolver;
	};
	return styled$3;
}
function generateDisplayName(componentName, componentSlot, tag) {
	if (componentName) return `${componentName}${capitalize(componentSlot || "")}`;
	return `Styled(${getDisplayName(tag)})`;
}
function generateStyledLabel(componentName, componentSlot) {
	let label;
	if (componentName) label = `${componentName}-${lowercaseFirstLetter(componentSlot || "Root")}`;
	return label;
}
function isObjectEmpty(object) {
	for (const _ in object) return false;
	return true;
}
function isStringTag(tag) {
	return typeof tag === "string" && tag.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(string) {
	if (!string) return string;
	return string.charAt(0).toLowerCase() + string.slice(1);
}

//#endregion
//#region node_modules/@mui/utils/esm/clamp/clamp.js
function clamp(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
	return Math.max(min, Math.min(val, max));
}
var clamp_default = clamp;

//#endregion
//#region node_modules/@mui/system/esm/colorManipulator/colorManipulator.js
/**
* Returns a number whose value is limited to the given range.
* @param {number} value The value to be clamped
* @param {number} min The lower boundary of the output range
* @param {number} max The upper boundary of the output range
* @returns {number} A number in the range [min, max]
*/
function clampWrapper(value, min = 0, max = 1) {
	if (value < min || value > max) console.error(`MUI: The value provided ${value} is out of range [${min}, ${max}].`);
	return clamp_default(value, min, max);
}
/**
* Converts a color from CSS hex format to CSS rgb format.
* @param {string} color - Hex color, i.e. #nnn or #nnnnnn
* @returns {string} A CSS rgb color string
*/
function hexToRgb(color$1) {
	color$1 = color$1.slice(1);
	const re = new RegExp(`.{1,${color$1.length >= 6 ? 2 : 1}}`, "g");
	let colors = color$1.match(re);
	if (colors && colors[0].length === 1) colors = colors.map((n) => n + n);
	if (color$1.length !== color$1.trim().length) console.error(`MUI: The color: "${color$1}" is invalid. Make sure the color input doesn't contain leading/trailing space.`);
	return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index) => {
		return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
	}).join(", ")})` : "";
}
/**
* Returns an object with the type and values of a color.
*
* Note: Does not support rgb % values.
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @returns {object} - A MUI color object: {type: string, values: number[]}
*/
function decomposeColor(color$1) {
	if (color$1.type) return color$1;
	if (color$1.charAt(0) === "#") return decomposeColor(hexToRgb(color$1));
	const marker = color$1.indexOf("(");
	const type = color$1.substring(0, marker);
	if (![
		"rgb",
		"rgba",
		"hsl",
		"hsla",
		"color"
	].includes(type)) throw new Error(`MUI: Unsupported \`${color$1}\` color.\nThe following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().`);
	let values$1 = color$1.substring(marker + 1, color$1.length - 1);
	let colorSpace;
	if (type === "color") {
		values$1 = values$1.split(" ");
		colorSpace = values$1.shift();
		if (values$1.length === 4 && values$1[3].charAt(0) === "/") values$1[3] = values$1[3].slice(1);
		if (![
			"srgb",
			"display-p3",
			"a98-rgb",
			"prophoto-rgb",
			"rec-2020"
		].includes(colorSpace)) throw new Error(`MUI: unsupported \`${colorSpace}\` color space.\nThe following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.`);
	} else values$1 = values$1.split(",");
	values$1 = values$1.map((value) => parseFloat(value));
	return {
		type,
		values: values$1,
		colorSpace
	};
}
/**
* Returns a channel created from the input color.
*
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @returns {string} - The channel for the color, that can be used in rgba or hsla colors
*/
const colorChannel = (color$1) => {
	const decomposedColor = decomposeColor(color$1);
	return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
};
const private_safeColorChannel = (color$1, warning) => {
	try {
		return colorChannel(color$1);
	} catch (error) {
		if (warning && true) console.warn(warning);
		return color$1;
	}
};
/**
* Converts a color object with type and values to a string.
* @param {object} color - Decomposed color
* @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla', 'color'
* @param {array} color.values - [n,n,n] or [n,n,n,n]
* @returns {string} A CSS color string
*/
function recomposeColor(color$1) {
	const { type, colorSpace } = color$1;
	let { values: values$1 } = color$1;
	if (type.includes("rgb")) values$1 = values$1.map((n, i) => i < 3 ? parseInt(n, 10) : n);
	else if (type.includes("hsl")) {
		values$1[1] = `${values$1[1]}%`;
		values$1[2] = `${values$1[2]}%`;
	}
	if (type.includes("color")) values$1 = `${colorSpace} ${values$1.join(" ")}`;
	else values$1 = `${values$1.join(", ")}`;
	return `${type}(${values$1})`;
}
/**
* Converts a color from hsl format to rgb format.
* @param {string} color - HSL color values
* @returns {string} rgb color values
*/
function hslToRgb(color$1) {
	color$1 = decomposeColor(color$1);
	const { values: values$1 } = color$1;
	const h = values$1[0];
	const s = values$1[1] / 100;
	const l = values$1[2] / 100;
	const a = s * Math.min(l, 1 - l);
	const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
	let type = "rgb";
	const rgb = [
		Math.round(f(0) * 255),
		Math.round(f(8) * 255),
		Math.round(f(4) * 255)
	];
	if (color$1.type === "hsla") {
		type += "a";
		rgb.push(values$1[3]);
	}
	return recomposeColor({
		type,
		values: rgb
	});
}
/**
* The relative brightness of any point in a color space,
* normalized to 0 for darkest black and 1 for lightest white.
*
* Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @returns {number} The relative brightness of the color in the range 0 - 1
*/
function getLuminance(color$1) {
	color$1 = decomposeColor(color$1);
	let rgb = color$1.type === "hsl" || color$1.type === "hsla" ? decomposeColor(hslToRgb(color$1)).values : color$1.values;
	rgb = rgb.map((val) => {
		if (color$1.type !== "color") val /= 255;
		return val <= .03928 ? val / 12.92 : ((val + .055) / 1.055) ** 2.4;
	});
	return Number((.2126 * rgb[0] + .7152 * rgb[1] + .0722 * rgb[2]).toFixed(3));
}
/**
* Calculates the contrast ratio between two colors.
*
* Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
* @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
* @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
* @returns {number} A contrast ratio value in the range 0 - 21.
*/
function getContrastRatio(foreground, background) {
	const lumA = getLuminance(foreground);
	const lumB = getLuminance(background);
	return (Math.max(lumA, lumB) + .05) / (Math.min(lumA, lumB) + .05);
}
/**
* Sets the absolute transparency of a color.
* Any existing alpha values are overwritten.
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @param {number} value - value to set the alpha channel to in the range 0 - 1
* @returns {string} A CSS color string. Hex input values are returned as rgb
*/
function alpha(color$1, value) {
	color$1 = decomposeColor(color$1);
	value = clampWrapper(value);
	if (color$1.type === "rgb" || color$1.type === "hsl") color$1.type += "a";
	if (color$1.type === "color") color$1.values[3] = `/${value}`;
	else color$1.values[3] = value;
	return recomposeColor(color$1);
}
function private_safeAlpha(color$1, value, warning) {
	try {
		return alpha(color$1, value);
	} catch (error) {
		if (warning && true) console.warn(warning);
		return color$1;
	}
}
/**
* Darkens a color.
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @param {number} coefficient - multiplier in the range 0 - 1
* @returns {string} A CSS color string. Hex input values are returned as rgb
*/
function darken(color$1, coefficient) {
	color$1 = decomposeColor(color$1);
	coefficient = clampWrapper(coefficient);
	if (color$1.type.includes("hsl")) color$1.values[2] *= 1 - coefficient;
	else if (color$1.type.includes("rgb") || color$1.type.includes("color")) for (let i = 0; i < 3; i += 1) color$1.values[i] *= 1 - coefficient;
	return recomposeColor(color$1);
}
function private_safeDarken(color$1, coefficient, warning) {
	try {
		return darken(color$1, coefficient);
	} catch (error) {
		if (warning && true) console.warn(warning);
		return color$1;
	}
}
/**
* Lightens a color.
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @param {number} coefficient - multiplier in the range 0 - 1
* @returns {string} A CSS color string. Hex input values are returned as rgb
*/
function lighten(color$1, coefficient) {
	color$1 = decomposeColor(color$1);
	coefficient = clampWrapper(coefficient);
	if (color$1.type.includes("hsl")) color$1.values[2] += (100 - color$1.values[2]) * coefficient;
	else if (color$1.type.includes("rgb")) for (let i = 0; i < 3; i += 1) color$1.values[i] += (255 - color$1.values[i]) * coefficient;
	else if (color$1.type.includes("color")) for (let i = 0; i < 3; i += 1) color$1.values[i] += (1 - color$1.values[i]) * coefficient;
	return recomposeColor(color$1);
}
function private_safeLighten(color$1, coefficient, warning) {
	try {
		return lighten(color$1, coefficient);
	} catch (error) {
		if (warning && true) console.warn(warning);
		return color$1;
	}
}
/**
* Darken or lighten a color, depending on its luminance.
* Light colors are darkened, dark colors are lightened.
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @param {number} coefficient=0.15 - multiplier in the range 0 - 1
* @returns {string} A CSS color string. Hex input values are returned as rgb
*/
function emphasize(color$1, coefficient = .15) {
	return getLuminance(color$1) > .5 ? darken(color$1, coefficient) : lighten(color$1, coefficient);
}
function private_safeEmphasize(color$1, coefficient, warning) {
	try {
		return emphasize(color$1, coefficient);
	} catch (error) {
		if (warning && true) console.warn(warning);
		return color$1;
	}
}

//#endregion
//#region node_modules/@mui/system/esm/memoTheme.js
var arg = { theme: void 0 };
/**
* Memoize style function on theme.
* Intended to be used in styled() calls that only need access to the theme.
*/
function unstable_memoTheme(styleFn) {
	let lastValue;
	let lastTheme;
	return function styleMemoized(props) {
		let value = lastValue;
		if (value === void 0 || props.theme !== lastTheme) {
			arg.theme = props.theme;
			value = preprocessStyles(styleFn(arg));
			lastValue = value;
			lastTheme = props.theme;
		}
		return value;
	};
}

//#endregion
//#region node_modules/@mui/system/esm/cssVars/createGetCssVar.js
/**
* The benefit of this function is to help developers get CSS var from theme without specifying the whole variable
* and they does not need to remember the prefix (defined once).
*/
function createGetCssVar(prefix = "") {
	function appendVar(...vars) {
		if (!vars.length) return "";
		const value = vars[0];
		if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) return `, var(--${prefix ? `${prefix}-` : ""}${value}${appendVar(...vars.slice(1))})`;
		return `, ${value}`;
	}
	const getCssVar = (field, ...fallbacks) => {
		return `var(--${prefix ? `${prefix}-` : ""}${field}${appendVar(...fallbacks)})`;
	};
	return getCssVar;
}

//#endregion
//#region node_modules/@mui/system/esm/cssVars/cssVarsParser.js
/**
* This function create an object from keys, value and then assign to target
*
* @param {Object} obj : the target object to be assigned
* @param {string[]} keys
* @param {string | number} value
*
* @example
* const source = {}
* assignNestedKeys(source, ['palette', 'primary'], 'var(--palette-primary)')
* console.log(source) // { palette: { primary: 'var(--palette-primary)' } }
*
* @example
* const source = { palette: { primary: 'var(--palette-primary)' } }
* assignNestedKeys(source, ['palette', 'secondary'], 'var(--palette-secondary)')
* console.log(source) // { palette: { primary: 'var(--palette-primary)', secondary: 'var(--palette-secondary)' } }
*/
const assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
	let temp = obj;
	keys.forEach((k, index) => {
		if (index === keys.length - 1) {
			if (Array.isArray(temp)) temp[Number(k)] = value;
			else if (temp && typeof temp === "object") temp[k] = value;
		} else if (temp && typeof temp === "object") {
			if (!temp[k]) temp[k] = arrayKeys.includes(k) ? [] : {};
			temp = temp[k];
		}
	});
};
/**
*
* @param {Object} obj : source object
* @param {Function} callback : a function that will be called when
*                   - the deepest key in source object is reached
*                   - the value of the deepest key is NOT `undefined` | `null`
*
* @example
* walkObjectDeep({ palette: { primary: { main: '#000000' } } }, console.log)
* // ['palette', 'primary', 'main'] '#000000'
*/
const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
	function recurse(object, parentKeys = [], arrayKeys = []) {
		Object.entries(object).forEach(([key, value]) => {
			if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
				if (value !== void 0 && value !== null) if (typeof value === "object" && Object.keys(value).length > 0) recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
				else callback([...parentKeys, key], value, arrayKeys);
			}
		});
	}
	recurse(obj);
};
var getCssValue = (keys, value) => {
	if (typeof value === "number") {
		if ([
			"lineHeight",
			"fontWeight",
			"opacity",
			"zIndex"
		].some((prop) => keys.includes(prop))) return value;
		if (keys[keys.length - 1].toLowerCase().includes("opacity")) return value;
		return `${value}px`;
	}
	return value;
};
/**
* a function that parse theme and return { css, vars }
*
* @param {Object} theme
* @param {{
*  prefix?: string,
*  shouldSkipGeneratingVar?: (objectPathKeys: Array<string>, value: string | number) => boolean
* }} options.
*  `prefix`: The prefix of the generated CSS variables. This function does not change the value.
*
* @returns {{ css: Object, vars: Object }} `css` is the stylesheet, `vars` is an object to get css variable (same structure as theme).
*
* @example
* const { css, vars } = parser({
*   fontSize: 12,
*   lineHeight: 1.2,
*   palette: { primary: { 500: 'var(--color)' } }
* }, { prefix: 'foo' })
*
* console.log(css) // { '--foo-fontSize': '12px', '--foo-lineHeight': 1.2, '--foo-palette-primary-500': 'var(--color)' }
* console.log(vars) // { fontSize: 'var(--foo-fontSize)', lineHeight: 'var(--foo-lineHeight)', palette: { primary: { 500: 'var(--foo-palette-primary-500)' } } }
*/
function cssVarsParser(theme, options) {
	const { prefix, shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 } = options || {};
	const css$1 = {};
	const vars = {};
	const varsWithDefaults = {};
	walkObjectDeep(theme, (keys, value, arrayKeys) => {
		if (typeof value === "string" || typeof value === "number") {
			if (!shouldSkipGeneratingVar$1 || !shouldSkipGeneratingVar$1(keys, value)) {
				const cssVar = `--${prefix ? `${prefix}-` : ""}${keys.join("-")}`;
				const resolvedValue = getCssValue(keys, value);
				Object.assign(css$1, { [cssVar]: resolvedValue });
				assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
				assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
			}
		}
	}, (keys) => keys[0] === "vars");
	return {
		css: css$1,
		vars,
		varsWithDefaults
	};
}

//#endregion
//#region node_modules/@mui/system/esm/cssVars/prepareCssVars.js
function prepareCssVars(theme, parserConfig = {}) {
	const { getSelector = defaultGetSelector, disableCssColorScheme, colorSchemeSelector: selector, enableContrastVars } = parserConfig;
	const { colorSchemes = {}, components, defaultColorScheme = "light",...otherTheme } = theme;
	const { vars: rootVars, css: rootCss, varsWithDefaults: rootVarsWithDefaults } = cssVarsParser(otherTheme, parserConfig);
	let themeVars = rootVarsWithDefaults;
	const colorSchemesMap = {};
	const { [defaultColorScheme]: defaultScheme,...otherColorSchemes } = colorSchemes;
	Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
		const { vars, css: css$1, varsWithDefaults } = cssVarsParser(scheme, parserConfig);
		themeVars = deepmerge(themeVars, varsWithDefaults);
		colorSchemesMap[key] = {
			css: css$1,
			vars
		};
	});
	if (defaultScheme) {
		const { css: css$1, vars, varsWithDefaults } = cssVarsParser(defaultScheme, parserConfig);
		themeVars = deepmerge(themeVars, varsWithDefaults);
		colorSchemesMap[defaultColorScheme] = {
			css: css$1,
			vars
		};
	}
	function defaultGetSelector(colorScheme, cssObject) {
		let rule = selector;
		if (selector === "class") rule = ".%s";
		if (selector === "data") rule = "[data-%s]";
		if (selector?.startsWith("data-") && !selector.includes("%s")) rule = `[${selector}="%s"]`;
		if (colorScheme) {
			if (rule === "media") {
				if (theme.defaultColorScheme === colorScheme) return ":root";
				return { [`@media (prefers-color-scheme: ${colorSchemes[colorScheme]?.palette?.mode || colorScheme})`]: { ":root": cssObject } };
			}
			if (rule) {
				if (theme.defaultColorScheme === colorScheme) return `:root, ${rule.replace("%s", String(colorScheme))}`;
				return rule.replace("%s", String(colorScheme));
			}
		}
		return ":root";
	}
	const generateThemeVars = () => {
		let vars = { ...rootVars };
		Object.entries(colorSchemesMap).forEach(([, { vars: schemeVars }]) => {
			vars = deepmerge(vars, schemeVars);
		});
		return vars;
	};
	const generateStyleSheets = () => {
		const stylesheets = [];
		const colorScheme = theme.defaultColorScheme || "light";
		function insertStyleSheet(key, css$1) {
			if (Object.keys(css$1).length) stylesheets.push(typeof key === "string" ? { [key]: { ...css$1 } } : key);
		}
		insertStyleSheet(getSelector(void 0, { ...rootCss }), rootCss);
		const { [colorScheme]: defaultSchemeVal,...other } = colorSchemesMap;
		if (defaultSchemeVal) {
			const { css: css$1 } = defaultSchemeVal;
			const cssColorSheme = colorSchemes[colorScheme]?.palette?.mode;
			const finalCss = !disableCssColorScheme && cssColorSheme ? {
				colorScheme: cssColorSheme,
				...css$1
			} : { ...css$1 };
			insertStyleSheet(getSelector(colorScheme, { ...finalCss }), finalCss);
		}
		Object.entries(other).forEach(([key, { css: css$1 }]) => {
			const cssColorSheme = colorSchemes[key]?.palette?.mode;
			const finalCss = !disableCssColorScheme && cssColorSheme ? {
				colorScheme: cssColorSheme,
				...css$1
			} : { ...css$1 };
			insertStyleSheet(getSelector(key, { ...finalCss }), finalCss);
		});
		if (enableContrastVars) stylesheets.push({ ":root": {
			"--__l-threshold": "0.7",
			"--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
			"--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
		} });
		return stylesheets;
	};
	return {
		vars: themeVars,
		generateThemeVars,
		generateStyleSheets
	};
}
var prepareCssVars_default = prepareCssVars;

//#endregion
//#region node_modules/@mui/system/esm/cssVars/getColorSchemeSelector.js
function createGetColorSchemeSelector(selector) {
	return function getColorSchemeSelector(colorScheme) {
		if (selector === "media") {
			if (colorScheme !== "light" && colorScheme !== "dark") console.error(`MUI: @media (prefers-color-scheme) supports only 'light' or 'dark', but receive '${colorScheme}'.`);
			return `@media (prefers-color-scheme: ${colorScheme})`;
		}
		if (selector) {
			if (selector.startsWith("data-") && !selector.includes("%s")) return `[${selector}="${colorScheme}"] &`;
			if (selector === "class") return `.${colorScheme} &`;
			if (selector === "data") return `[data-${colorScheme}] &`;
			return `${selector.replace("%s", colorScheme)} &`;
		}
		return "&";
	};
}

//#endregion
//#region node_modules/@mui/material/esm/colors/common.js
var common = {
	black: "#000",
	white: "#fff"
};
var common_default = common;

//#endregion
//#region node_modules/@mui/material/esm/colors/grey.js
var grey = {
	50: "#fafafa",
	100: "#f5f5f5",
	200: "#eeeeee",
	300: "#e0e0e0",
	400: "#bdbdbd",
	500: "#9e9e9e",
	600: "#757575",
	700: "#616161",
	800: "#424242",
	900: "#212121",
	A100: "#f5f5f5",
	A200: "#eeeeee",
	A400: "#bdbdbd",
	A700: "#616161"
};
var grey_default = grey;

//#endregion
//#region node_modules/@mui/material/esm/colors/purple.js
var purple = {
	50: "#f3e5f5",
	100: "#e1bee7",
	200: "#ce93d8",
	300: "#ba68c8",
	400: "#ab47bc",
	500: "#9c27b0",
	600: "#8e24aa",
	700: "#7b1fa2",
	800: "#6a1b9a",
	900: "#4a148c",
	A100: "#ea80fc",
	A200: "#e040fb",
	A400: "#d500f9",
	A700: "#aa00ff"
};
var purple_default = purple;

//#endregion
//#region node_modules/@mui/material/esm/colors/red.js
var red = {
	50: "#ffebee",
	100: "#ffcdd2",
	200: "#ef9a9a",
	300: "#e57373",
	400: "#ef5350",
	500: "#f44336",
	600: "#e53935",
	700: "#d32f2f",
	800: "#c62828",
	900: "#b71c1c",
	A100: "#ff8a80",
	A200: "#ff5252",
	A400: "#ff1744",
	A700: "#d50000"
};
var red_default = red;

//#endregion
//#region node_modules/@mui/material/esm/colors/orange.js
var orange = {
	50: "#fff3e0",
	100: "#ffe0b2",
	200: "#ffcc80",
	300: "#ffb74d",
	400: "#ffa726",
	500: "#ff9800",
	600: "#fb8c00",
	700: "#f57c00",
	800: "#ef6c00",
	900: "#e65100",
	A100: "#ffd180",
	A200: "#ffab40",
	A400: "#ff9100",
	A700: "#ff6d00"
};
var orange_default = orange;

//#endregion
//#region node_modules/@mui/material/esm/colors/blue.js
var blue = {
	50: "#e3f2fd",
	100: "#bbdefb",
	200: "#90caf9",
	300: "#64b5f6",
	400: "#42a5f5",
	500: "#2196f3",
	600: "#1e88e5",
	700: "#1976d2",
	800: "#1565c0",
	900: "#0d47a1",
	A100: "#82b1ff",
	A200: "#448aff",
	A400: "#2979ff",
	A700: "#2962ff"
};
var blue_default = blue;

//#endregion
//#region node_modules/@mui/material/esm/colors/lightBlue.js
var lightBlue = {
	50: "#e1f5fe",
	100: "#b3e5fc",
	200: "#81d4fa",
	300: "#4fc3f7",
	400: "#29b6f6",
	500: "#03a9f4",
	600: "#039be5",
	700: "#0288d1",
	800: "#0277bd",
	900: "#01579b",
	A100: "#80d8ff",
	A200: "#40c4ff",
	A400: "#00b0ff",
	A700: "#0091ea"
};
var lightBlue_default = lightBlue;

//#endregion
//#region node_modules/@mui/material/esm/colors/green.js
var green = {
	50: "#e8f5e9",
	100: "#c8e6c9",
	200: "#a5d6a7",
	300: "#81c784",
	400: "#66bb6a",
	500: "#4caf50",
	600: "#43a047",
	700: "#388e3c",
	800: "#2e7d32",
	900: "#1b5e20",
	A100: "#b9f6ca",
	A200: "#69f0ae",
	A400: "#00e676",
	A700: "#00c853"
};
var green_default = green;

//#endregion
//#region node_modules/@mui/material/esm/styles/createPalette.js
function getLight() {
	return {
		text: {
			primary: "rgba(0, 0, 0, 0.87)",
			secondary: "rgba(0, 0, 0, 0.6)",
			disabled: "rgba(0, 0, 0, 0.38)"
		},
		divider: "rgba(0, 0, 0, 0.12)",
		background: {
			paper: common_default.white,
			default: common_default.white
		},
		action: {
			active: "rgba(0, 0, 0, 0.54)",
			hover: "rgba(0, 0, 0, 0.04)",
			hoverOpacity: .04,
			selected: "rgba(0, 0, 0, 0.08)",
			selectedOpacity: .08,
			disabled: "rgba(0, 0, 0, 0.26)",
			disabledBackground: "rgba(0, 0, 0, 0.12)",
			disabledOpacity: .38,
			focus: "rgba(0, 0, 0, 0.12)",
			focusOpacity: .12,
			activatedOpacity: .12
		}
	};
}
const light = getLight();
function getDark() {
	return {
		text: {
			primary: common_default.white,
			secondary: "rgba(255, 255, 255, 0.7)",
			disabled: "rgba(255, 255, 255, 0.5)",
			icon: "rgba(255, 255, 255, 0.5)"
		},
		divider: "rgba(255, 255, 255, 0.12)",
		background: {
			paper: "#121212",
			default: "#121212"
		},
		action: {
			active: common_default.white,
			hover: "rgba(255, 255, 255, 0.08)",
			hoverOpacity: .08,
			selected: "rgba(255, 255, 255, 0.16)",
			selectedOpacity: .16,
			disabled: "rgba(255, 255, 255, 0.3)",
			disabledBackground: "rgba(255, 255, 255, 0.12)",
			disabledOpacity: .38,
			focus: "rgba(255, 255, 255, 0.12)",
			focusOpacity: .12,
			activatedOpacity: .24
		}
	};
}
const dark = getDark();
function addLightOrDark(intent, direction, shade, tonalOffset) {
	const tonalOffsetLight = tonalOffset.light || tonalOffset;
	const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
	if (!intent[direction]) {
		if (intent.hasOwnProperty(shade)) intent[direction] = intent[shade];
		else if (direction === "light") intent.light = lighten(intent.main, tonalOffsetLight);
		else if (direction === "dark") intent.dark = darken(intent.main, tonalOffsetDark);
	}
}
function mixLightOrDark(colorSpace, intent, direction, shade, tonalOffset) {
	const tonalOffsetLight = tonalOffset.light || tonalOffset;
	const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
	if (!intent[direction]) {
		if (intent.hasOwnProperty(shade)) intent[direction] = intent[shade];
		else if (direction === "light") intent.light = `color-mix(in ${colorSpace}, ${intent.main}, #fff ${(tonalOffsetLight * 100).toFixed(0)}%)`;
		else if (direction === "dark") intent.dark = `color-mix(in ${colorSpace}, ${intent.main}, #000 ${(tonalOffsetDark * 100).toFixed(0)}%)`;
	}
}
function getDefaultPrimary(mode = "light") {
	if (mode === "dark") return {
		main: blue_default[200],
		light: blue_default[50],
		dark: blue_default[400]
	};
	return {
		main: blue_default[700],
		light: blue_default[400],
		dark: blue_default[800]
	};
}
function getDefaultSecondary(mode = "light") {
	if (mode === "dark") return {
		main: purple_default[200],
		light: purple_default[50],
		dark: purple_default[400]
	};
	return {
		main: purple_default[500],
		light: purple_default[300],
		dark: purple_default[700]
	};
}
function getDefaultError(mode = "light") {
	if (mode === "dark") return {
		main: red_default[500],
		light: red_default[300],
		dark: red_default[700]
	};
	return {
		main: red_default[700],
		light: red_default[400],
		dark: red_default[800]
	};
}
function getDefaultInfo(mode = "light") {
	if (mode === "dark") return {
		main: lightBlue_default[400],
		light: lightBlue_default[300],
		dark: lightBlue_default[700]
	};
	return {
		main: lightBlue_default[700],
		light: lightBlue_default[500],
		dark: lightBlue_default[900]
	};
}
function getDefaultSuccess(mode = "light") {
	if (mode === "dark") return {
		main: green_default[400],
		light: green_default[300],
		dark: green_default[700]
	};
	return {
		main: green_default[800],
		light: green_default[500],
		dark: green_default[900]
	};
}
function getDefaultWarning(mode = "light") {
	if (mode === "dark") return {
		main: orange_default[400],
		light: orange_default[300],
		dark: orange_default[700]
	};
	return {
		main: "#ed6c02",
		light: orange_default[500],
		dark: orange_default[900]
	};
}
function contrastColor(background) {
	return `oklch(from ${background} var(--__l) 0 h / var(--__a))`;
}
function createPalette(palette$1) {
	const { mode = "light", contrastThreshold = 3, tonalOffset = .2, colorSpace,...other } = palette$1;
	const primary = palette$1.primary || getDefaultPrimary(mode);
	const secondary = palette$1.secondary || getDefaultSecondary(mode);
	const error = palette$1.error || getDefaultError(mode);
	const info = palette$1.info || getDefaultInfo(mode);
	const success = palette$1.success || getDefaultSuccess(mode);
	const warning = palette$1.warning || getDefaultWarning(mode);
	function getContrastText(background) {
		if (colorSpace) return contrastColor(background);
		const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
		{
			const contrast = getContrastRatio(background, contrastText);
			if (contrast < 3) console.error([
				`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`,
				"falls below the WCAG recommended absolute minimum contrast ratio of 3:1.",
				"https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"
			].join("\n"));
		}
		return contrastText;
	}
	const augmentColor = ({ color: color$1, name, mainShade = 500, lightShade = 300, darkShade = 700 }) => {
		color$1 = { ...color$1 };
		if (!color$1.main && color$1[mainShade]) color$1.main = color$1[mainShade];
		if (!color$1.hasOwnProperty("main")) throw new Error(`MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.\nThe color object needs to have a \`main\` property or a \`${mainShade}\` property.`);
		if (typeof color$1.main !== "string") throw new Error(`MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.\n\`color.main\` should be a string, but \`${JSON.stringify(color$1.main)}\` was provided instead.\n
Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });`);
		if (colorSpace) {
			mixLightOrDark(colorSpace, color$1, "light", lightShade, tonalOffset);
			mixLightOrDark(colorSpace, color$1, "dark", darkShade, tonalOffset);
		} else {
			addLightOrDark(color$1, "light", lightShade, tonalOffset);
			addLightOrDark(color$1, "dark", darkShade, tonalOffset);
		}
		if (!color$1.contrastText) color$1.contrastText = getContrastText(color$1.main);
		return color$1;
	};
	let modeHydrated;
	if (mode === "light") modeHydrated = getLight();
	else if (mode === "dark") modeHydrated = getDark();
	if (!modeHydrated) console.error(`MUI: The palette mode \`${mode}\` is not supported.`);
	return deepmerge({
		common: { ...common_default },
		mode,
		primary: augmentColor({
			color: primary,
			name: "primary"
		}),
		secondary: augmentColor({
			color: secondary,
			name: "secondary",
			mainShade: "A400",
			lightShade: "A200",
			darkShade: "A700"
		}),
		error: augmentColor({
			color: error,
			name: "error"
		}),
		warning: augmentColor({
			color: warning,
			name: "warning"
		}),
		info: augmentColor({
			color: info,
			name: "info"
		}),
		success: augmentColor({
			color: success,
			name: "success"
		}),
		grey: grey_default,
		contrastThreshold,
		getContrastText,
		augmentColor,
		tonalOffset,
		...modeHydrated
	}, other);
}

//#endregion
//#region node_modules/@mui/system/esm/cssVars/prepareTypographyVars.js
function prepareTypographyVars(typography) {
	const vars = {};
	Object.entries(typography).forEach((entry) => {
		const [key, value] = entry;
		if (typeof value === "object") vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
	});
	return vars;
}

//#endregion
//#region node_modules/@mui/material/esm/styles/createMixins.js
function createMixins(breakpoints, mixins) {
	return {
		toolbar: {
			minHeight: 56,
			[breakpoints.up("xs")]: { "@media (orientation: landscape)": { minHeight: 48 } },
			[breakpoints.up("sm")]: { minHeight: 64 }
		},
		...mixins
	};
}

//#endregion
//#region node_modules/@mui/material/esm/styles/createTypography.js
function round(value) {
	return Math.round(value * 1e5) / 1e5;
}
var caseAllCaps = { textTransform: "uppercase" };
var defaultFontFamily = "\"Roboto\", \"Helvetica\", \"Arial\", sans-serif";
/**
* @see @link{https://m2.material.io/design/typography/the-type-system.html}
* @see @link{https://m2.material.io/design/typography/understanding-typography.html}
*/
function createTypography(palette$1, typography) {
	const { fontFamily = defaultFontFamily, fontSize = 14, fontWeightLight = 300, fontWeightRegular = 400, fontWeightMedium = 500, fontWeightBold = 700, htmlFontSize = 16, allVariants, pxToRem: pxToRem2,...other } = typeof typography === "function" ? typography(palette$1) : typography;
	if (typeof fontSize !== "number") console.error("MUI: `fontSize` is required to be a number.");
	if (typeof htmlFontSize !== "number") console.error("MUI: `htmlFontSize` is required to be a number.");
	const coef = fontSize / 14;
	const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
	const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => ({
		fontFamily,
		fontWeight,
		fontSize: pxToRem(size),
		lineHeight,
		...fontFamily === defaultFontFamily ? { letterSpacing: `${round(letterSpacing / size)}em` } : {},
		...casing,
		...allVariants
	});
	const variants = {
		h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
		h2: buildVariant(fontWeightLight, 60, 1.2, -.5),
		h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
		h4: buildVariant(fontWeightRegular, 34, 1.235, .25),
		h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
		h6: buildVariant(fontWeightMedium, 20, 1.6, .15),
		subtitle1: buildVariant(fontWeightRegular, 16, 1.75, .15),
		subtitle2: buildVariant(fontWeightMedium, 14, 1.57, .1),
		body1: buildVariant(fontWeightRegular, 16, 1.5, .15),
		body2: buildVariant(fontWeightRegular, 14, 1.43, .15),
		button: buildVariant(fontWeightMedium, 14, 1.75, .4, caseAllCaps),
		caption: buildVariant(fontWeightRegular, 12, 1.66, .4),
		overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
		inherit: {
			fontFamily: "inherit",
			fontWeight: "inherit",
			fontSize: "inherit",
			lineHeight: "inherit",
			letterSpacing: "inherit"
		}
	};
	return deepmerge({
		htmlFontSize,
		pxToRem,
		fontFamily,
		fontSize,
		fontWeightLight,
		fontWeightRegular,
		fontWeightMedium,
		fontWeightBold,
		...variants
	}, other, { clone: false });
}

//#endregion
//#region node_modules/@mui/material/esm/styles/shadows.js
var shadowKeyUmbraOpacity = .2;
var shadowKeyPenumbraOpacity = .14;
var shadowAmbientShadowOpacity = .12;
function createShadow(...px) {
	return [
		`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`,
		`${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`,
		`${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`
	].join(",");
}
var shadows = [
	"none",
	createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
	createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
	createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
	createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
	createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
	createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
	createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
	createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
	createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
	createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
	createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
	createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
	createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
	createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
	createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
	createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
	createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
	createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
	createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
	createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
	createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
	createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
	createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
	createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)
];
var shadows_default = shadows;

//#endregion
//#region node_modules/@mui/material/esm/styles/createTransitions.js
const easing = {
	easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
	easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
	easeIn: "cubic-bezier(0.4, 0, 1, 1)",
	sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
	shortest: 150,
	shorter: 200,
	short: 250,
	standard: 300,
	complex: 375,
	enteringScreen: 225,
	leavingScreen: 195
};
function formatMs(milliseconds) {
	return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height$1) {
	if (!height$1) return 0;
	const constant = height$1 / 36;
	return Math.min(Math.round((4 + 15 * constant ** .25 + constant / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
	const mergedEasing = {
		...easing,
		...inputTransitions.easing
	};
	const mergedDuration = {
		...duration,
		...inputTransitions.duration
	};
	const create = (props = ["all"], options = {}) => {
		const { duration: durationOption = mergedDuration.standard, easing: easingOption = mergedEasing.easeInOut, delay = 0,...other } = options;
		{
			const isString = (value) => typeof value === "string";
			const isNumber = (value) => !Number.isNaN(parseFloat(value));
			if (!isString(props) && !Array.isArray(props)) console.error("MUI: Argument \"props\" must be a string or Array.");
			if (!isNumber(durationOption) && !isString(durationOption)) console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
			if (!isString(easingOption)) console.error("MUI: Argument \"easing\" must be a string.");
			if (!isNumber(delay) && !isString(delay)) console.error("MUI: Argument \"delay\" must be a number or a string.");
			if (typeof options !== "object") console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join("\n"));
			if (Object.keys(other).length !== 0) console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(",")}].`);
		}
		return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
	};
	return {
		getAutoHeightDuration,
		create,
		...inputTransitions,
		easing: mergedEasing,
		duration: mergedDuration
	};
}

//#endregion
//#region node_modules/@mui/material/esm/styles/zIndex.js
var zIndex = {
	mobileStepper: 1e3,
	fab: 1050,
	speedDial: 1050,
	appBar: 1100,
	drawer: 1200,
	modal: 1300,
	snackbar: 1400,
	tooltip: 1500
};
var zIndex_default = zIndex;

//#endregion
//#region node_modules/@mui/material/esm/styles/stringifyTheme.js
function isSerializable(val) {
	return isPlainObject(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
}
/**
* `baseTheme` usually comes from `createTheme()` or `extendTheme()`.
*
* This function is intended to be used with zero-runtime CSS-in-JS like Pigment CSS
* For example, in a Next.js project:
*
* ```js
* // next.config.js
* const { extendTheme } = require('@mui/material/styles');
*
* const theme = extendTheme();
* // `.toRuntimeSource` is Pigment CSS specific to create a theme that is available at runtime.
* theme.toRuntimeSource = stringifyTheme;
*
* module.exports = withPigment({
*  theme,
* });
* ```
*/
function stringifyTheme(baseTheme = {}) {
	const serializableTheme = { ...baseTheme };
	function serializeTheme(object) {
		const array = Object.entries(object);
		for (let index = 0; index < array.length; index++) {
			const [key, value] = array[index];
			if (!isSerializable(value) || key.startsWith("unstable_")) delete object[key];
			else if (isPlainObject(value)) {
				object[key] = { ...value };
				serializeTheme(object[key]);
			}
		}
	}
	serializeTheme(serializableTheme);
	return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}

//#endregion
//#region node_modules/@mui/material/esm/styles/createThemeNoVars.js
function coefficientToPercentage(coefficient) {
	if (typeof coefficient === "number") return `${(coefficient * 100).toFixed(0)}%`;
	return `calc((${coefficient}) * 100%)`;
}
var parseAddition = (str) => {
	if (!Number.isNaN(+str)) return +str;
	const numbers = str.match(/\d*\.?\d+/g);
	if (!numbers) return 0;
	let sum = 0;
	for (let i = 0; i < numbers.length; i += 1) sum += +numbers[i];
	return sum;
};
function attachColorManipulators(theme) {
	Object.assign(theme, {
		alpha(color$1, coefficient) {
			const obj = this || theme;
			if (obj.colorSpace) return `oklch(from ${color$1} l c h / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
			if (obj.vars) return `rgba(${color$1.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
			return alpha(color$1, parseAddition(coefficient));
		},
		lighten(color$1, coefficient) {
			const obj = this || theme;
			if (obj.colorSpace) return `color-mix(in ${obj.colorSpace}, ${color$1}, #fff ${coefficientToPercentage(coefficient)})`;
			return lighten(color$1, coefficient);
		},
		darken(color$1, coefficient) {
			const obj = this || theme;
			if (obj.colorSpace) return `color-mix(in ${obj.colorSpace}, ${color$1}, #000 ${coefficientToPercentage(coefficient)})`;
			return darken(color$1, coefficient);
		}
	});
}
function createThemeNoVars(options = {}, ...args) {
	const { breakpoints: breakpointsInput, mixins: mixinsInput = {}, spacing: spacingInput, palette: paletteInput = {}, transitions: transitionsInput = {}, typography: typographyInput = {}, shape: shapeInput, colorSpace,...other } = options;
	if (options.vars && options.generateThemeVars === void 0) throw new Error("MUI: `vars` is a private field used for CSS variables support.\nPlease use another name or follow the [docs](https://mui.com/material-ui/customization/css-theme-variables/usage/) to enable the feature.");
	const palette$1 = createPalette({
		...paletteInput,
		colorSpace
	});
	const systemTheme = createTheme_default(options);
	let muiTheme = deepmerge(systemTheme, {
		mixins: createMixins(systemTheme.breakpoints, mixinsInput),
		palette: palette$1,
		shadows: shadows_default.slice(),
		typography: createTypography(palette$1, typographyInput),
		transitions: createTransitions(transitionsInput),
		zIndex: { ...zIndex_default }
	});
	muiTheme = deepmerge(muiTheme, other);
	muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
	{
		const stateClasses = [
			"active",
			"checked",
			"completed",
			"disabled",
			"error",
			"expanded",
			"focused",
			"focusVisible",
			"required",
			"selected"
		];
		const traverse = (node, component) => {
			let key;
			for (key in node) {
				const child = node[key];
				if (stateClasses.includes(key) && Object.keys(child).length > 0) {
					{
						const stateClass = generateUtilityClass("", key);
						console.error([
							`MUI: The \`${component}\` component increases the CSS specificity of the \`${key}\` internal state.`,
							"You can not override it like this: ",
							JSON.stringify(node, null, 2),
							"",
							`Instead, you need to use the '&.${stateClass}' syntax:`,
							JSON.stringify({ root: { [`&.${stateClass}`]: child } }, null, 2),
							"",
							"https://mui.com/r/state-classes-guide"
						].join("\n"));
					}
					node[key] = {};
				}
			}
		};
		Object.keys(muiTheme.components).forEach((component) => {
			const styleOverrides = muiTheme.components[component].styleOverrides;
			if (styleOverrides && component.startsWith("Mui")) traverse(styleOverrides, component);
		});
	}
	muiTheme.unstable_sxConfig = {
		...defaultSxConfig_default,
		...other?.unstable_sxConfig
	};
	muiTheme.unstable_sx = function sx(props) {
		return styleFunctionSx_default({
			sx: props,
			theme: this
		});
	};
	muiTheme.toRuntimeSource = stringifyTheme;
	attachColorManipulators(muiTheme);
	return muiTheme;
}
var createThemeNoVars_default = createThemeNoVars;

//#endregion
//#region node_modules/@mui/material/esm/styles/getOverlayAlpha.js
function getOverlayAlpha(elevation) {
	let alphaValue;
	if (elevation < 1) alphaValue = 5.11916 * elevation ** 2;
	else alphaValue = 4.5 * Math.log(elevation + 1) + 2;
	return Math.round(alphaValue * 10) / 1e3;
}

//#endregion
//#region node_modules/@mui/material/esm/styles/createColorScheme.js
var defaultDarkOverlays = [...Array(25)].map((_, index) => {
	if (index === 0) return "none";
	const overlay = getOverlayAlpha(index);
	return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode) {
	return {
		inputPlaceholder: mode === "dark" ? .5 : .42,
		inputUnderline: mode === "dark" ? .7 : .42,
		switchTrackDisabled: mode === "dark" ? .2 : .12,
		switchTrack: mode === "dark" ? .3 : .38
	};
}
function getOverlays(mode) {
	return mode === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
	const { palette: paletteInput = { mode: "light" }, opacity, overlays, colorSpace,...other } = options;
	const palette$1 = createPalette({
		...paletteInput,
		colorSpace
	});
	return {
		palette: palette$1,
		opacity: {
			...getOpacity(palette$1.mode),
			...opacity
		},
		overlays: overlays || getOverlays(palette$1.mode),
		...other
	};
}

//#endregion
//#region node_modules/@mui/material/esm/styles/shouldSkipGeneratingVar.js
function shouldSkipGeneratingVar(keys) {
	return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || keys[0] === "palette" && !!keys[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}

//#endregion
//#region node_modules/@mui/material/esm/styles/excludeVariablesFromRoot.js
/**
* @internal These variables should not appear in the :root stylesheet when the `defaultColorScheme="dark"`
*/
var excludeVariablesFromRoot = (cssVarPrefix) => [
	...[...Array(25)].map((_, index) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index}`),
	`--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`,
	`--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`
];
var excludeVariablesFromRoot_default = excludeVariablesFromRoot;

//#endregion
//#region node_modules/@mui/material/esm/styles/createGetSelector.js
var createGetSelector_default = (theme) => (colorScheme, css$1) => {
	const root = theme.rootSelector || ":root";
	const selector = theme.colorSchemeSelector;
	let rule = selector;
	if (selector === "class") rule = ".%s";
	if (selector === "data") rule = "[data-%s]";
	if (selector?.startsWith("data-") && !selector.includes("%s")) rule = `[${selector}="%s"]`;
	if (theme.defaultColorScheme === colorScheme) {
		if (colorScheme === "dark") {
			const excludedVariables = {};
			excludeVariablesFromRoot_default(theme.cssVarPrefix).forEach((cssVar) => {
				excludedVariables[cssVar] = css$1[cssVar];
				delete css$1[cssVar];
			});
			if (rule === "media") return {
				[root]: css$1,
				[`@media (prefers-color-scheme: dark)`]: { [root]: excludedVariables }
			};
			if (rule) return {
				[rule.replace("%s", colorScheme)]: excludedVariables,
				[`${root}, ${rule.replace("%s", colorScheme)}`]: css$1
			};
			return { [root]: {
				...css$1,
				...excludedVariables
			} };
		}
		if (rule && rule !== "media") return `${root}, ${rule.replace("%s", String(colorScheme))}`;
	} else if (colorScheme) {
		if (rule === "media") return { [`@media (prefers-color-scheme: ${String(colorScheme)})`]: { [root]: css$1 } };
		if (rule) return rule.replace("%s", String(colorScheme));
	}
	return root;
};

//#endregion
//#region node_modules/@mui/material/esm/styles/createThemeWithVars.js
function assignNode(obj, keys) {
	keys.forEach((k) => {
		if (!obj[k]) obj[k] = {};
	});
}
function setColor(obj, key, defaultValue) {
	if (!obj[key] && defaultValue) obj[key] = defaultValue;
}
function toRgb(color$1) {
	if (typeof color$1 !== "string" || !color$1.startsWith("hsl")) return color$1;
	return hslToRgb(color$1);
}
function setColorChannel(obj, key) {
	if (!(`${key}Channel` in obj)) obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]), `MUI: Can't create \`palette.${key}Channel\` because \`palette.${key}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${key}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`);
}
function getSpacingVal(spacingInput) {
	if (typeof spacingInput === "number") return `${spacingInput}px`;
	if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) return spacingInput;
	return "8px";
}
var silent = (fn) => {
	try {
		return fn();
	} catch (error) {}
};
const createGetCssVar$1 = (cssVarPrefix = "mui") => createGetCssVar(cssVarPrefix);
function attachColorScheme$1(colorSpace, colorSchemes, scheme, restTheme, colorScheme) {
	if (!scheme) return;
	scheme = scheme === true ? {} : scheme;
	const mode = colorScheme === "dark" ? "dark" : "light";
	if (!restTheme) {
		colorSchemes[colorScheme] = createColorScheme({
			...scheme,
			palette: {
				mode,
				...scheme?.palette
			},
			colorSpace
		});
		return;
	}
	const { palette: palette$1,...muiTheme } = createThemeNoVars_default({
		...restTheme,
		palette: {
			mode,
			...scheme?.palette
		},
		colorSpace
	});
	colorSchemes[colorScheme] = {
		...scheme,
		palette: palette$1,
		opacity: {
			...getOpacity(mode),
			...scheme?.opacity
		},
		overlays: scheme?.overlays || getOverlays(mode)
	};
	return muiTheme;
}
/**
* A default `createThemeWithVars` comes with a single color scheme, either `light` or `dark` based on the `defaultColorScheme`.
* This is better suited for apps that only need a single color scheme.
*
* To enable built-in `light` and `dark` color schemes, either:
* 1. provide a `colorSchemeSelector` to define how the color schemes will change.
* 2. provide `colorSchemes.dark` will set `colorSchemeSelector: 'media'` by default.
*/
function createThemeWithVars(options = {}, ...args) {
	const { colorSchemes: colorSchemesInput = { light: true }, defaultColorScheme: defaultColorSchemeInput, disableCssColorScheme = false, cssVarPrefix = "mui", nativeColor = false, shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar, colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0, rootSelector = ":root",...input } = options;
	const firstColorScheme = Object.keys(colorSchemesInput)[0];
	const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
	const getCssVar = createGetCssVar$1(cssVarPrefix);
	const { [defaultColorScheme]: defaultSchemeInput, light: builtInLight, dark: builtInDark,...customColorSchemes } = colorSchemesInput;
	const colorSchemes = { ...customColorSchemes };
	let defaultScheme = defaultSchemeInput;
	if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) defaultScheme = true;
	if (!defaultScheme) throw new Error(`MUI: The \`colorSchemes.${defaultColorScheme}\` option is either missing or invalid.`);
	let colorSpace;
	if (nativeColor) colorSpace = "oklch";
	const muiTheme = attachColorScheme$1(colorSpace, colorSchemes, defaultScheme, input, defaultColorScheme);
	if (builtInLight && !colorSchemes.light) attachColorScheme$1(colorSpace, colorSchemes, builtInLight, void 0, "light");
	if (builtInDark && !colorSchemes.dark) attachColorScheme$1(colorSpace, colorSchemes, builtInDark, void 0, "dark");
	let theme = {
		defaultColorScheme,
		...muiTheme,
		cssVarPrefix,
		colorSchemeSelector: selector,
		rootSelector,
		getCssVar,
		colorSchemes,
		font: {
			...prepareTypographyVars(muiTheme.typography),
			...muiTheme.font
		},
		spacing: getSpacingVal(input.spacing)
	};
	Object.keys(theme.colorSchemes).forEach((key) => {
		const palette$1 = theme.colorSchemes[key].palette;
		const setCssVarColor = (cssVar) => {
			const tokens = cssVar.split("-");
			const color$1 = tokens[1];
			const colorToken = tokens[2];
			return getCssVar(cssVar, palette$1[color$1][colorToken]);
		};
		if (palette$1.mode === "light") {
			setColor(palette$1.common, "background", "#fff");
			setColor(palette$1.common, "onBackground", "#000");
		}
		if (palette$1.mode === "dark") {
			setColor(palette$1.common, "background", "#000");
			setColor(palette$1.common, "onBackground", "#fff");
		}
		function colorMix(method, color$1, coefficient) {
			if (colorSpace) {
				let mixer;
				if (method === private_safeAlpha) mixer = `transparent ${((1 - coefficient) * 100).toFixed(0)}%`;
				if (method === private_safeDarken) mixer = `#000 ${(coefficient * 100).toFixed(0)}%`;
				if (method === private_safeLighten) mixer = `#fff ${(coefficient * 100).toFixed(0)}%`;
				return `color-mix(in ${colorSpace}, ${color$1}, ${mixer})`;
			}
			return method(color$1, coefficient);
		}
		assignNode(palette$1, [
			"Alert",
			"AppBar",
			"Avatar",
			"Button",
			"Chip",
			"FilledInput",
			"LinearProgress",
			"Skeleton",
			"Slider",
			"SnackbarContent",
			"SpeedDialAction",
			"StepConnector",
			"StepContent",
			"Switch",
			"TableCell",
			"Tooltip"
		]);
		if (palette$1.mode === "light") {
			setColor(palette$1.Alert, "errorColor", colorMix(private_safeDarken, palette$1.error.light, .6));
			setColor(palette$1.Alert, "infoColor", colorMix(private_safeDarken, palette$1.info.light, .6));
			setColor(palette$1.Alert, "successColor", colorMix(private_safeDarken, palette$1.success.light, .6));
			setColor(palette$1.Alert, "warningColor", colorMix(private_safeDarken, palette$1.warning.light, .6));
			setColor(palette$1.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
			setColor(palette$1.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
			setColor(palette$1.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
			setColor(palette$1.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
			setColor(palette$1.Alert, "errorFilledColor", silent(() => palette$1.getContrastText(palette$1.error.main)));
			setColor(palette$1.Alert, "infoFilledColor", silent(() => palette$1.getContrastText(palette$1.info.main)));
			setColor(palette$1.Alert, "successFilledColor", silent(() => palette$1.getContrastText(palette$1.success.main)));
			setColor(palette$1.Alert, "warningFilledColor", silent(() => palette$1.getContrastText(palette$1.warning.main)));
			setColor(palette$1.Alert, "errorStandardBg", colorMix(private_safeLighten, palette$1.error.light, .9));
			setColor(palette$1.Alert, "infoStandardBg", colorMix(private_safeLighten, palette$1.info.light, .9));
			setColor(palette$1.Alert, "successStandardBg", colorMix(private_safeLighten, palette$1.success.light, .9));
			setColor(palette$1.Alert, "warningStandardBg", colorMix(private_safeLighten, palette$1.warning.light, .9));
			setColor(palette$1.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
			setColor(palette$1.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
			setColor(palette$1.Alert, "successIconColor", setCssVarColor("palette-success-main"));
			setColor(palette$1.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
			setColor(palette$1.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
			setColor(palette$1.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
			setColor(palette$1.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
			setColor(palette$1.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
			setColor(palette$1.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
			setColor(palette$1.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
			setColor(palette$1.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
			setColor(palette$1.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
			setColor(palette$1.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
			setColor(palette$1.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
			setColor(palette$1.LinearProgress, "primaryBg", colorMix(private_safeLighten, palette$1.primary.main, .62));
			setColor(palette$1.LinearProgress, "secondaryBg", colorMix(private_safeLighten, palette$1.secondary.main, .62));
			setColor(palette$1.LinearProgress, "errorBg", colorMix(private_safeLighten, palette$1.error.main, .62));
			setColor(palette$1.LinearProgress, "infoBg", colorMix(private_safeLighten, palette$1.info.main, .62));
			setColor(palette$1.LinearProgress, "successBg", colorMix(private_safeLighten, palette$1.success.main, .62));
			setColor(palette$1.LinearProgress, "warningBg", colorMix(private_safeLighten, palette$1.warning.main, .62));
			setColor(palette$1.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette$1.text.primary, .11) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
			setColor(palette$1.Slider, "primaryTrack", colorMix(private_safeLighten, palette$1.primary.main, .62));
			setColor(palette$1.Slider, "secondaryTrack", colorMix(private_safeLighten, palette$1.secondary.main, .62));
			setColor(palette$1.Slider, "errorTrack", colorMix(private_safeLighten, palette$1.error.main, .62));
			setColor(palette$1.Slider, "infoTrack", colorMix(private_safeLighten, palette$1.info.main, .62));
			setColor(palette$1.Slider, "successTrack", colorMix(private_safeLighten, palette$1.success.main, .62));
			setColor(palette$1.Slider, "warningTrack", colorMix(private_safeLighten, palette$1.warning.main, .62));
			const snackbarContentBackground = colorSpace ? colorMix(private_safeDarken, palette$1.background.default, .6825) : private_safeEmphasize(palette$1.background.default, .8);
			setColor(palette$1.SnackbarContent, "bg", snackbarContentBackground);
			setColor(palette$1.SnackbarContent, "color", silent(() => colorSpace ? dark.text.primary : palette$1.getContrastText(snackbarContentBackground)));
			setColor(palette$1.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette$1.background.paper, .15));
			setColor(palette$1.StepConnector, "border", setCssVarColor("palette-grey-400"));
			setColor(palette$1.StepContent, "border", setCssVarColor("palette-grey-400"));
			setColor(palette$1.Switch, "defaultColor", setCssVarColor("palette-common-white"));
			setColor(palette$1.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
			setColor(palette$1.Switch, "primaryDisabledColor", colorMix(private_safeLighten, palette$1.primary.main, .62));
			setColor(palette$1.Switch, "secondaryDisabledColor", colorMix(private_safeLighten, palette$1.secondary.main, .62));
			setColor(palette$1.Switch, "errorDisabledColor", colorMix(private_safeLighten, palette$1.error.main, .62));
			setColor(palette$1.Switch, "infoDisabledColor", colorMix(private_safeLighten, palette$1.info.main, .62));
			setColor(palette$1.Switch, "successDisabledColor", colorMix(private_safeLighten, palette$1.success.main, .62));
			setColor(palette$1.Switch, "warningDisabledColor", colorMix(private_safeLighten, palette$1.warning.main, .62));
			setColor(palette$1.TableCell, "border", colorMix(private_safeLighten, colorMix(private_safeAlpha, palette$1.divider, 1), .88));
			setColor(palette$1.Tooltip, "bg", colorMix(private_safeAlpha, palette$1.grey[700], .92));
		}
		if (palette$1.mode === "dark") {
			setColor(palette$1.Alert, "errorColor", colorMix(private_safeLighten, palette$1.error.light, .6));
			setColor(palette$1.Alert, "infoColor", colorMix(private_safeLighten, palette$1.info.light, .6));
			setColor(palette$1.Alert, "successColor", colorMix(private_safeLighten, palette$1.success.light, .6));
			setColor(palette$1.Alert, "warningColor", colorMix(private_safeLighten, palette$1.warning.light, .6));
			setColor(palette$1.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
			setColor(palette$1.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
			setColor(palette$1.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
			setColor(palette$1.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
			setColor(palette$1.Alert, "errorFilledColor", silent(() => palette$1.getContrastText(palette$1.error.dark)));
			setColor(palette$1.Alert, "infoFilledColor", silent(() => palette$1.getContrastText(palette$1.info.dark)));
			setColor(palette$1.Alert, "successFilledColor", silent(() => palette$1.getContrastText(palette$1.success.dark)));
			setColor(palette$1.Alert, "warningFilledColor", silent(() => palette$1.getContrastText(palette$1.warning.dark)));
			setColor(palette$1.Alert, "errorStandardBg", colorMix(private_safeDarken, palette$1.error.light, .9));
			setColor(palette$1.Alert, "infoStandardBg", colorMix(private_safeDarken, palette$1.info.light, .9));
			setColor(palette$1.Alert, "successStandardBg", colorMix(private_safeDarken, palette$1.success.light, .9));
			setColor(palette$1.Alert, "warningStandardBg", colorMix(private_safeDarken, palette$1.warning.light, .9));
			setColor(palette$1.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
			setColor(palette$1.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
			setColor(palette$1.Alert, "successIconColor", setCssVarColor("palette-success-main"));
			setColor(palette$1.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
			setColor(palette$1.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
			setColor(palette$1.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
			setColor(palette$1.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
			setColor(palette$1.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
			setColor(palette$1.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
			setColor(palette$1.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
			setColor(palette$1.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
			setColor(palette$1.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
			setColor(palette$1.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
			setColor(palette$1.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
			setColor(palette$1.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
			setColor(palette$1.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
			setColor(palette$1.LinearProgress, "primaryBg", colorMix(private_safeDarken, palette$1.primary.main, .5));
			setColor(palette$1.LinearProgress, "secondaryBg", colorMix(private_safeDarken, palette$1.secondary.main, .5));
			setColor(palette$1.LinearProgress, "errorBg", colorMix(private_safeDarken, palette$1.error.main, .5));
			setColor(palette$1.LinearProgress, "infoBg", colorMix(private_safeDarken, palette$1.info.main, .5));
			setColor(palette$1.LinearProgress, "successBg", colorMix(private_safeDarken, palette$1.success.main, .5));
			setColor(palette$1.LinearProgress, "warningBg", colorMix(private_safeDarken, palette$1.warning.main, .5));
			setColor(palette$1.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette$1.text.primary, .13) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
			setColor(palette$1.Slider, "primaryTrack", colorMix(private_safeDarken, palette$1.primary.main, .5));
			setColor(palette$1.Slider, "secondaryTrack", colorMix(private_safeDarken, palette$1.secondary.main, .5));
			setColor(palette$1.Slider, "errorTrack", colorMix(private_safeDarken, palette$1.error.main, .5));
			setColor(palette$1.Slider, "infoTrack", colorMix(private_safeDarken, palette$1.info.main, .5));
			setColor(palette$1.Slider, "successTrack", colorMix(private_safeDarken, palette$1.success.main, .5));
			setColor(palette$1.Slider, "warningTrack", colorMix(private_safeDarken, palette$1.warning.main, .5));
			const snackbarContentBackground = colorSpace ? colorMix(private_safeLighten, palette$1.background.default, .985) : private_safeEmphasize(palette$1.background.default, .98);
			setColor(palette$1.SnackbarContent, "bg", snackbarContentBackground);
			setColor(palette$1.SnackbarContent, "color", silent(() => colorSpace ? light.text.primary : palette$1.getContrastText(snackbarContentBackground)));
			setColor(palette$1.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette$1.background.paper, .15));
			setColor(palette$1.StepConnector, "border", setCssVarColor("palette-grey-600"));
			setColor(palette$1.StepContent, "border", setCssVarColor("palette-grey-600"));
			setColor(palette$1.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
			setColor(palette$1.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
			setColor(palette$1.Switch, "primaryDisabledColor", colorMix(private_safeDarken, palette$1.primary.main, .55));
			setColor(palette$1.Switch, "secondaryDisabledColor", colorMix(private_safeDarken, palette$1.secondary.main, .55));
			setColor(palette$1.Switch, "errorDisabledColor", colorMix(private_safeDarken, palette$1.error.main, .55));
			setColor(palette$1.Switch, "infoDisabledColor", colorMix(private_safeDarken, palette$1.info.main, .55));
			setColor(palette$1.Switch, "successDisabledColor", colorMix(private_safeDarken, palette$1.success.main, .55));
			setColor(palette$1.Switch, "warningDisabledColor", colorMix(private_safeDarken, palette$1.warning.main, .55));
			setColor(palette$1.TableCell, "border", colorMix(private_safeDarken, colorMix(private_safeAlpha, palette$1.divider, 1), .68));
			setColor(palette$1.Tooltip, "bg", colorMix(private_safeAlpha, palette$1.grey[700], .92));
		}
		setColorChannel(palette$1.background, "default");
		setColorChannel(palette$1.background, "paper");
		setColorChannel(palette$1.common, "background");
		setColorChannel(palette$1.common, "onBackground");
		setColorChannel(palette$1, "divider");
		Object.keys(palette$1).forEach((color$1) => {
			const colors = palette$1[color$1];
			if (color$1 !== "tonalOffset" && colors && typeof colors === "object") {
				if (colors.main) setColor(palette$1[color$1], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
				if (colors.light) setColor(palette$1[color$1], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
				if (colors.dark) setColor(palette$1[color$1], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
				if (colors.contrastText) setColor(palette$1[color$1], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
				if (color$1 === "text") {
					setColorChannel(palette$1[color$1], "primary");
					setColorChannel(palette$1[color$1], "secondary");
				}
				if (color$1 === "action") {
					if (colors.active) setColorChannel(palette$1[color$1], "active");
					if (colors.selected) setColorChannel(palette$1[color$1], "selected");
				}
			}
		});
	});
	theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
	const parserConfig = {
		prefix: cssVarPrefix,
		disableCssColorScheme,
		shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
		getSelector: createGetSelector_default(theme),
		enableContrastVars: nativeColor
	};
	const { vars, generateThemeVars, generateStyleSheets } = prepareCssVars_default(theme, parserConfig);
	theme.vars = vars;
	Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key, value]) => {
		theme[key] = value;
	});
	theme.generateThemeVars = generateThemeVars;
	theme.generateStyleSheets = generateStyleSheets;
	theme.generateSpacing = function generateSpacing() {
		return createSpacing(input.spacing, createUnarySpacing(this));
	};
	theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
	theme.spacing = theme.generateSpacing();
	theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
	theme.unstable_sxConfig = {
		...defaultSxConfig_default,
		...input?.unstable_sxConfig
	};
	theme.unstable_sx = function sx(props) {
		return styleFunctionSx_default({
			sx: props,
			theme: this
		});
	};
	theme.toRuntimeSource = stringifyTheme;
	return theme;
}

//#endregion
//#region node_modules/@mui/material/esm/styles/createTheme.js
function attachColorScheme(theme, scheme, colorScheme) {
	if (!theme.colorSchemes) return;
	if (colorScheme) theme.colorSchemes[scheme] = {
		...colorScheme !== true && colorScheme,
		palette: createPalette({
			...colorScheme === true ? {} : colorScheme.palette,
			mode: scheme
		})
	};
}
/**
* Generate a theme base on the options received.
* @param options Takes an incomplete theme object and adds the missing parts.
* @param args Deep merge the arguments with the about to be returned theme.
* @returns A complete, ready-to-use theme object.
*/
function createTheme(options = {}, ...args) {
	const { palette: palette$1, cssVariables = false, colorSchemes: initialColorSchemes = !palette$1 ? { light: true } : void 0, defaultColorScheme: initialDefaultColorScheme = palette$1?.mode,...other } = options;
	const defaultColorSchemeInput = initialDefaultColorScheme || "light";
	const defaultScheme = initialColorSchemes?.[defaultColorSchemeInput];
	const colorSchemesInput = {
		...initialColorSchemes,
		...palette$1 ? { [defaultColorSchemeInput]: {
			...typeof defaultScheme !== "boolean" && defaultScheme,
			palette: palette$1
		} } : void 0
	};
	if (cssVariables === false) {
		if (!("colorSchemes" in options)) return createThemeNoVars_default(options, ...args);
		let paletteOptions = palette$1;
		if (!("palette" in options)) {
			if (colorSchemesInput[defaultColorSchemeInput]) {
				if (colorSchemesInput[defaultColorSchemeInput] !== true) paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
				else if (defaultColorSchemeInput === "dark") paletteOptions = { mode: "dark" };
			}
		}
		const theme = createThemeNoVars_default({
			...options,
			palette: paletteOptions
		}, ...args);
		theme.defaultColorScheme = defaultColorSchemeInput;
		theme.colorSchemes = colorSchemesInput;
		if (theme.palette.mode === "light") {
			theme.colorSchemes.light = {
				...colorSchemesInput.light !== true && colorSchemesInput.light,
				palette: theme.palette
			};
			attachColorScheme(theme, "dark", colorSchemesInput.dark);
		}
		if (theme.palette.mode === "dark") {
			theme.colorSchemes.dark = {
				...colorSchemesInput.dark !== true && colorSchemesInput.dark,
				palette: theme.palette
			};
			attachColorScheme(theme, "light", colorSchemesInput.light);
		}
		return theme;
	}
	if (!palette$1 && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") colorSchemesInput.light = true;
	return createThemeWithVars({
		...other,
		colorSchemes: colorSchemesInput,
		defaultColorScheme: defaultColorSchemeInput,
		...typeof cssVariables !== "boolean" && cssVariables
	}, ...args);
}

//#endregion
//#region node_modules/@mui/material/esm/styles/defaultTheme.js
var defaultTheme = createTheme();
var defaultTheme_default = defaultTheme;

//#endregion
//#region node_modules/@mui/material/esm/styles/identifier.js
var identifier_default = "$$material";

//#endregion
//#region node_modules/@mui/material/esm/styles/useTheme.js
function useTheme() {
	const theme = useTheme_default(defaultTheme_default);
	import_react.useDebugValue(theme);
	return theme[identifier_default] || theme;
}

//#endregion
//#region node_modules/@mui/material/esm/styles/slotShouldForwardProp.js
function slotShouldForwardProp(prop) {
	return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
var slotShouldForwardProp_default = slotShouldForwardProp;

//#endregion
//#region node_modules/@mui/material/esm/styles/rootShouldForwardProp.js
var rootShouldForwardProp = (prop) => slotShouldForwardProp_default(prop) && prop !== "classes";
var rootShouldForwardProp_default = rootShouldForwardProp;

//#endregion
//#region node_modules/@mui/material/esm/styles/styled.js
var styled = createStyled({
	themeId: identifier_default,
	defaultTheme: defaultTheme_default,
	rootShouldForwardProp: rootShouldForwardProp_default
});
var styled_default = styled;

//#endregion
//#region node_modules/@mui/material/esm/zero-styled/index.js
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime(), 1);
function internal_createExtendSxProp() {
	return extendSxProp;
}

//#endregion
export { alpha, capitalize, duration, generateUtilityClass, getOverlayAlpha, internal_createExtendSxProp, styled_default, unstable_memoTheme, useTheme };
//# sourceMappingURL=zero-styled-n2GRcgfb.js.map